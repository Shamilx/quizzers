"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/crypto-ts";
exports.ids = ["vendor-chunks/crypto-ts"];
exports.modules = {

/***/ "(rsc)/./node_modules/crypto-ts/esm5/crypto-ts.js":
/*!**************************************************!*\
  !*** ./node_modules/crypto-ts/esm5/crypto-ts.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AES: () => (/* binding */ AES$1),\n/* harmony export */   SHA256: () => (/* binding */ SHA256$1),\n/* harmony export */   algo: () => (/* binding */ algo),\n/* harmony export */   enc: () => (/* binding */ enc),\n/* harmony export */   lib: () => (/* binding */ lib),\n/* harmony export */   mode: () => (/* binding */ mode),\n/* harmony export */   pad: () => (/* binding */ pad),\n/* harmony export */   \"ɵa\": () => (/* binding */ BlockCipher),\n/* harmony export */   \"ɵb\": () => (/* binding */ Cipher),\n/* harmony export */   \"ɵc\": () => (/* binding */ BufferedBlockAlgorithm),\n/* harmony export */   \"ɵe\": () => (/* binding */ WordArray),\n/* harmony export */   \"ɵf\": () => (/* binding */ CipherParams),\n/* harmony export */   \"ɵg\": () => (/* binding */ Base),\n/* harmony export */   \"ɵi\": () => (/* binding */ Hasher),\n/* harmony export */   \"ɵj\": () => (/* binding */ SerializableCipher),\n/* harmony export */   \"ɵk\": () => (/* binding */ PasswordBasedCipher),\n/* harmony export */   \"ɵl\": () => (/* binding */ AES),\n/* harmony export */   \"ɵm\": () => (/* binding */ SHA256),\n/* harmony export */   \"ɵn\": () => (/* binding */ Utf8),\n/* harmony export */   \"ɵo\": () => (/* binding */ Latin1),\n/* harmony export */   \"ɵp\": () => (/* binding */ Hex),\n/* harmony export */   \"ɵq\": () => (/* binding */ NoPadding),\n/* harmony export */   \"ɵr\": () => (/* binding */ PKCS7),\n/* harmony export */   \"ɵs\": () => (/* binding */ CBC),\n/* harmony export */   \"ɵt\": () => (/* binding */ BlockCipherMode),\n/* harmony export */   \"ɵu\": () => (/* binding */ ECB)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/crypto-ts/node_modules/tslib/tslib.es6.js\");\n/**\n * @license crypto-ts\n * MIT license\n */\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar Hex = /** @class */ (function () {\n    function Hex() {\n    }\n    /**\n     * Converts a word array to a hex string.\n     *\n     * \\@example\n     *\n     *     let hexString = Hex.stringify(wordArray);\n     * @param {?} wordArray The word array.\n     *\n     * @return {?} The hex string.\n     *\n     */\n    Hex.stringify = /**\n     * Converts a word array to a hex string.\n     *\n     * \\@example\n     *\n     *     let hexString = Hex.stringify(wordArray);\n     * @param {?} wordArray The word array.\n     *\n     * @return {?} The hex string.\n     *\n     */\n    function (wordArray) {\n        // Convert\n        var /** @type {?} */ hexChars = [];\n        for (var /** @type {?} */ i = 0; i < wordArray.sigBytes; i++) {\n            var /** @type {?} */ bite = (wordArray.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n            hexChars.push((bite >>> 4).toString(16));\n            hexChars.push((bite & 0x0f).toString(16));\n        }\n        return hexChars.join('');\n    };\n    /**\n     * Converts a hex string to a word array.\n     *\n     * \\@example\n     *\n     *     let wordArray = Hex.parse(hexString);\n     * @param {?} hexStr The hex string.\n     *\n     * @return {?} The word array.\n     *\n     */\n    Hex.parse = /**\n     * Converts a hex string to a word array.\n     *\n     * \\@example\n     *\n     *     let wordArray = Hex.parse(hexString);\n     * @param {?} hexStr The hex string.\n     *\n     * @return {?} The word array.\n     *\n     */\n    function (hexStr) {\n        // Shortcut\n        var /** @type {?} */ hexStrLength = hexStr.length;\n        // Convert\n        var /** @type {?} */ words = [];\n        for (var /** @type {?} */ i = 0; i < hexStrLength; i += 2) {\n            words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n        }\n        return new WordArray(words, hexStrLength / 2);\n    };\n    return Hex;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar WordArray = /** @class */ (function () {\n    /**\n     * Initializes a newly created word array.\n     *\n     * @param words (Optional) An array of 32-bit words.\n     * @param sigBytes (Optional) The number of significant bytes in the words.\n     *\n     * @example\n     *\n     *     let wordArray = new WordArray();\n     *     let wordArray = new WordArray([0x00010203, 0x04050607]);\n     *     let wordArray = new WordArray([0x00010203, 0x04050607], 6);\n     */\n    function WordArray(words, sigBytes) {\n        this.words = words || [];\n        if (sigBytes !== undefined) {\n            this.sigBytes = sigBytes;\n        }\n        else {\n            this.sigBytes = this.words.length * 4;\n        }\n    }\n    /**\n     * Creates a word array filled with random bytes.\n     *\n     * \\@example\n     *\n     *     let wordArray = WordArray.random(16);\n     * @param {?} nBytes The number of random bytes to generate.\n     *\n     * @return {?} The random word array.\n     *\n     */\n    WordArray.random = /**\n     * Creates a word array filled with random bytes.\n     *\n     * \\@example\n     *\n     *     let wordArray = WordArray.random(16);\n     * @param {?} nBytes The number of random bytes to generate.\n     *\n     * @return {?} The random word array.\n     *\n     */\n    function (nBytes) {\n        var /** @type {?} */ words = [];\n        var /** @type {?} */ r = (function (m_w) {\n            var /** @type {?} */ m_z = 0x3ade68b1;\n            var /** @type {?} */ mask = 0xffffffff;\n            return function () {\n                m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;\n                m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;\n                var /** @type {?} */ result = ((m_z << 0x10) + m_w) & mask;\n                result /= 0x100000000;\n                result += 0.5;\n                return result * (Math.random() > .5 ? 1 : -1);\n            };\n        });\n        for (var /** @type {?} */ i = 0, /** @type {?} */ rcache = void 0; i < nBytes; i += 4) {\n            var /** @type {?} */ _r = r((rcache || Math.random()) * 0x100000000);\n            rcache = _r() * 0x3ade67b7;\n            words.push((_r() * 0x100000000) | 0);\n        }\n        return new WordArray(words, nBytes);\n    };\n    /**\n     * Converts this word array to a string.\n     *\n     * @param encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n     *\n     * @return The stringified word array.\n     *\n     * @example\n     *\n     *     let string = wordArray + '';\n     *     let string = wordArray.toString();\n     *     let string = wordArray.toString(CryptoJS.enc.Utf8);\n     */\n    /**\n     * Converts this word array to a string.\n     *\n     * \\@example\n     *\n     *     let string = wordArray + '';\n     *     let string = wordArray.toString();\n     *     let string = wordArray.toString(CryptoJS.enc.Utf8);\n     * @param {?=} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n     *\n     * @return {?} The stringified word array.\n     *\n     */\n    WordArray.prototype.toString = /**\n     * Converts this word array to a string.\n     *\n     * \\@example\n     *\n     *     let string = wordArray + '';\n     *     let string = wordArray.toString();\n     *     let string = wordArray.toString(CryptoJS.enc.Utf8);\n     * @param {?=} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n     *\n     * @return {?} The stringified word array.\n     *\n     */\n    function (encoder) {\n        return (encoder || Hex).stringify(this);\n    };\n    /**\n     * Concatenates a word array to this word array.\n     *\n     * @param wordArray The word array to append.\n     *\n     * @return This word array.\n     *\n     * @example\n     *\n     *     wordArray1.concat(wordArray2);\n     */\n    /**\n     * Concatenates a word array to this word array.\n     *\n     * \\@example\n     *\n     *     wordArray1.concat(wordArray2);\n     * @param {?} wordArray The word array to append.\n     *\n     * @return {?} This word array.\n     *\n     */\n    WordArray.prototype.concat = /**\n     * Concatenates a word array to this word array.\n     *\n     * \\@example\n     *\n     *     wordArray1.concat(wordArray2);\n     * @param {?} wordArray The word array to append.\n     *\n     * @return {?} This word array.\n     *\n     */\n    function (wordArray) {\n        // Clamp excess bits\n        this.clamp();\n        // Concat\n        if (this.sigBytes % 4) {\n            // Copy one byte at a time\n            for (var /** @type {?} */ i = 0; i < wordArray.sigBytes; i++) {\n                var /** @type {?} */ thatByte = (wordArray.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n                this.words[(this.sigBytes + i) >>> 2] |= thatByte << (24 - ((this.sigBytes + i) % 4) * 8);\n            }\n        }\n        else {\n            // Copy one word at a time\n            for (var /** @type {?} */ i = 0; i < wordArray.sigBytes; i += 4) {\n                this.words[(this.sigBytes + i) >>> 2] = wordArray.words[i >>> 2];\n            }\n        }\n        this.sigBytes += wordArray.sigBytes;\n        // Chainable\n        return this;\n    };\n    /**\n     * Removes insignificant bits.\n     *\n     * @example\n     *\n     *     wordArray.clamp();\n     */\n    /**\n     * Removes insignificant bits.\n     *\n     * \\@example\n     *\n     *     wordArray.clamp();\n     * @return {?}\n     */\n    WordArray.prototype.clamp = /**\n     * Removes insignificant bits.\n     *\n     * \\@example\n     *\n     *     wordArray.clamp();\n     * @return {?}\n     */\n    function () {\n        // Clamp\n        this.words[this.sigBytes >>> 2] &= 0xffffffff << (32 - (this.sigBytes % 4) * 8);\n        this.words.length = Math.ceil(this.sigBytes / 4);\n    };\n    /**\n     * Creates a copy of this word array.\n     *\n     * @return The clone.\n     *\n     * @example\n     *\n     *     let clone = wordArray.clone();\n     */\n    /**\n     * Creates a copy of this word array.\n     *\n     * \\@example\n     *\n     *     let clone = wordArray.clone();\n     * @return {?} The clone.\n     *\n     */\n    WordArray.prototype.clone = /**\n     * Creates a copy of this word array.\n     *\n     * \\@example\n     *\n     *     let clone = wordArray.clone();\n     * @return {?} The clone.\n     *\n     */\n    function () {\n        return new WordArray(this.words.slice(0), this.sigBytes);\n    };\n    return WordArray;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar Latin1 = /** @class */ (function () {\n    function Latin1() {\n    }\n    /**\n     * Converts a word array to a Latin1 string.\n     *\n     * \\@example\n     *\n     *     let latin1String = Latin1.stringify(wordArray);\n     * @param {?} wordArray The word array.\n     *\n     * @return {?} The Latin1 string.\n     *\n     */\n    Latin1.stringify = /**\n     * Converts a word array to a Latin1 string.\n     *\n     * \\@example\n     *\n     *     let latin1String = Latin1.stringify(wordArray);\n     * @param {?} wordArray The word array.\n     *\n     * @return {?} The Latin1 string.\n     *\n     */\n    function (wordArray) {\n        // Convert\n        var /** @type {?} */ latin1Chars = [];\n        for (var /** @type {?} */ i = 0; i < wordArray.sigBytes; i++) {\n            var /** @type {?} */ bite = (wordArray.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n            latin1Chars.push(String.fromCharCode(bite));\n        }\n        return latin1Chars.join('');\n    };\n    /**\n     * Converts a Latin1 string to a word array.\n     *\n     * \\@example\n     *\n     *     let wordArray = Latin1.parse(latin1String);\n     * @param {?} latin1Str The Latin1 string.\n     *\n     * @return {?} The word array.\n     *\n     */\n    Latin1.parse = /**\n     * Converts a Latin1 string to a word array.\n     *\n     * \\@example\n     *\n     *     let wordArray = Latin1.parse(latin1String);\n     * @param {?} latin1Str The Latin1 string.\n     *\n     * @return {?} The word array.\n     *\n     */\n    function (latin1Str) {\n        // Shortcut\n        var /** @type {?} */ latin1StrLength = latin1Str.length;\n        // Convert\n        var /** @type {?} */ words = [];\n        for (var /** @type {?} */ i = 0; i < latin1StrLength; i++) {\n            words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n        }\n        return new WordArray(words, latin1StrLength);\n    };\n    return Latin1;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar Utf8 = /** @class */ (function () {\n    function Utf8() {\n    }\n    /**\n     * Converts a word array to a UTF-8 string.\n     *\n     * \\@example\n     *\n     *     let utf8String = Utf8.stringify(wordArray);\n     * @param {?} wordArray The word array.\n     *\n     * @return {?} The UTF-8 string.\n     *\n     */\n    Utf8.stringify = /**\n     * Converts a word array to a UTF-8 string.\n     *\n     * \\@example\n     *\n     *     let utf8String = Utf8.stringify(wordArray);\n     * @param {?} wordArray The word array.\n     *\n     * @return {?} The UTF-8 string.\n     *\n     */\n    function (wordArray) {\n        try {\n            return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n        }\n        catch (/** @type {?} */ e) {\n            throw new Error('Malformed UTF-8 data');\n        }\n    };\n    /**\n     * Converts a UTF-8 string to a word array.\n     *\n     * \\@example\n     *\n     *     let wordArray = Utf8.parse(utf8String);\n     * @param {?} utf8Str The UTF-8 string.\n     *\n     * @return {?} The word array.\n     *\n     */\n    Utf8.parse = /**\n     * Converts a UTF-8 string to a word array.\n     *\n     * \\@example\n     *\n     *     let wordArray = Utf8.parse(utf8String);\n     * @param {?} utf8Str The UTF-8 string.\n     *\n     * @return {?} The word array.\n     *\n     */\n    function (utf8Str) {\n        return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n    };\n    return Utf8;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @abstract\n */\nvar  /**\n * @abstract\n */\nBufferedBlockAlgorithm = /** @class */ (function () {\n    function BufferedBlockAlgorithm(cfg) {\n        this._minBufferSize = 0;\n        this.cfg = Object.assign({\n            blockSize: 1\n        }, cfg);\n        // Initial values\n        this._data = new WordArray();\n        this._nDataBytes = 0;\n    }\n    /**\n     * Resets this block algorithm's data buffer to its initial state.\n     *\n     * @example\n     *\n     *     bufferedBlockAlgorithm.reset();\n     */\n    /**\n     * Resets this block algorithm's data buffer to its initial state.\n     *\n     * \\@example\n     *\n     *     bufferedBlockAlgorithm.reset();\n     * @return {?}\n     */\n    BufferedBlockAlgorithm.prototype.reset = /**\n     * Resets this block algorithm's data buffer to its initial state.\n     *\n     * \\@example\n     *\n     *     bufferedBlockAlgorithm.reset();\n     * @return {?}\n     */\n    function () {\n        // Initial values\n        this._data = new WordArray();\n        this._nDataBytes = 0;\n    };\n    /**\n     * Adds new data to this block algorithm's buffer.\n     *\n     * @param data The data to append. Strings are converted to a WordArray using UTF-8.\n     *\n     * @example\n     *\n     *     bufferedBlockAlgorithm._append('data');\n     *     bufferedBlockAlgorithm._append(wordArray);\n     */\n    /**\n     * Adds new data to this block algorithm's buffer.\n     *\n     * \\@example\n     *\n     *     bufferedBlockAlgorithm._append('data');\n     *     bufferedBlockAlgorithm._append(wordArray);\n     * @param {?} data The data to append. Strings are converted to a WordArray using UTF-8.\n     *\n     * @return {?}\n     */\n    BufferedBlockAlgorithm.prototype._append = /**\n     * Adds new data to this block algorithm's buffer.\n     *\n     * \\@example\n     *\n     *     bufferedBlockAlgorithm._append('data');\n     *     bufferedBlockAlgorithm._append(wordArray);\n     * @param {?} data The data to append. Strings are converted to a WordArray using UTF-8.\n     *\n     * @return {?}\n     */\n    function (data) {\n        // Convert string to WordArray, else assume WordArray already\n        if (typeof data === 'string') {\n            data = Utf8.parse(data);\n        }\n        // Append\n        this._data.concat(data);\n        this._nDataBytes += data.sigBytes;\n    };\n    /**\n     * Processes available data blocks.\n     *\n     * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n     *\n     * @param doFlush Whether all blocks and partial blocks should be processed.\n     *\n     * @return The processed data.\n     *\n     * @example\n     *\n     *     let processedData = bufferedBlockAlgorithm._process();\n     *     let processedData = bufferedBlockAlgorithm._process(!!'flush');\n     */\n    /**\n     * Processes available data blocks.\n     *\n     * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n     *\n     * \\@example\n     *\n     *     let processedData = bufferedBlockAlgorithm._process();\n     *     let processedData = bufferedBlockAlgorithm._process(!!'flush');\n     * @param {?=} doFlush Whether all blocks and partial blocks should be processed.\n     *\n     * @return {?} The processed data.\n     *\n     */\n    BufferedBlockAlgorithm.prototype._process = /**\n     * Processes available data blocks.\n     *\n     * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n     *\n     * \\@example\n     *\n     *     let processedData = bufferedBlockAlgorithm._process();\n     *     let processedData = bufferedBlockAlgorithm._process(!!'flush');\n     * @param {?=} doFlush Whether all blocks and partial blocks should be processed.\n     *\n     * @return {?} The processed data.\n     *\n     */\n    function (doFlush) {\n        if (!this.cfg.blockSize) {\n            throw new Error('missing blockSize in config');\n        }\n        // Shortcuts\n        var /** @type {?} */ blockSizeBytes = this.cfg.blockSize * 4;\n        // Count blocks ready\n        var /** @type {?} */ nBlocksReady = this._data.sigBytes / blockSizeBytes;\n        if (doFlush) {\n            // Round up to include partial blocks\n            nBlocksReady = Math.ceil(nBlocksReady);\n        }\n        else {\n            // Round down to include only full blocks,\n            // less the number of blocks that must remain in the buffer\n            nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n        }\n        // Count words ready\n        var /** @type {?} */ nWordsReady = nBlocksReady * this.cfg.blockSize;\n        // Count bytes ready\n        var /** @type {?} */ nBytesReady = Math.min(nWordsReady * 4, this._data.sigBytes);\n        // Process blocks\n        var /** @type {?} */ processedWords;\n        if (nWordsReady) {\n            for (var /** @type {?} */ offset = 0; offset < nWordsReady; offset += this.cfg.blockSize) {\n                // Perform concrete-algorithm logic\n                this._doProcessBlock(this._data.words, offset);\n            }\n            // Remove processed words\n            processedWords = this._data.words.splice(0, nWordsReady);\n            this._data.sigBytes -= nBytesReady;\n        }\n        // Return processed words\n        return new WordArray(processedWords, nBytesReady);\n    };\n    /**\n     * Creates a copy of this object.\n     *\n     * @return The clone.\n     *\n     * @example\n     *\n     *     let clone = bufferedBlockAlgorithm.clone();\n     */\n    /**\n     * Creates a copy of this object.\n     *\n     * \\@example\n     *\n     *     let clone = bufferedBlockAlgorithm.clone();\n     * @return {?} The clone.\n     *\n     */\n    BufferedBlockAlgorithm.prototype.clone = /**\n     * Creates a copy of this object.\n     *\n     * \\@example\n     *\n     *     let clone = bufferedBlockAlgorithm.clone();\n     * @return {?} The clone.\n     *\n     */\n    function () {\n        var /** @type {?} */ clone = this.constructor();\n        for (var /** @type {?} */ attr in this) {\n            if (this.hasOwnProperty(attr)) {\n                clone[attr] = this[attr];\n            }\n        }\n        clone._data = this._data.clone();\n        return clone;\n    };\n    return BufferedBlockAlgorithm;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar Base = /** @class */ (function () {\n    function Base() {\n    }\n    return Base;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar CipherParams = /** @class */ (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(CipherParams, _super);\n    function CipherParams(cipherParams) {\n        var _this = _super.call(this) || this;\n        _this.ciphertext = cipherParams.ciphertext;\n        _this.key = cipherParams.key;\n        _this.iv = cipherParams.iv;\n        _this.salt = cipherParams.salt;\n        _this.algorithm = cipherParams.algorithm;\n        _this.mode = cipherParams.mode;\n        _this.padding = cipherParams.padding;\n        _this.blockSize = cipherParams.blockSize;\n        _this.formatter = cipherParams.formatter;\n        return _this;\n    }\n    /**\n     * @param {?} additionalParams\n     * @return {?}\n     */\n    CipherParams.prototype.extend = /**\n     * @param {?} additionalParams\n     * @return {?}\n     */\n    function (additionalParams) {\n        if (additionalParams.ciphertext !== undefined) {\n            this.ciphertext = additionalParams.ciphertext;\n        }\n        if (additionalParams.key !== undefined) {\n            this.key = additionalParams.key;\n        }\n        if (additionalParams.iv !== undefined) {\n            this.iv = additionalParams.iv;\n        }\n        if (additionalParams.salt !== undefined) {\n            this.salt = additionalParams.salt;\n        }\n        if (additionalParams.algorithm !== undefined) {\n            this.algorithm = additionalParams.algorithm;\n        }\n        if (additionalParams.mode !== undefined) {\n            this.mode = additionalParams.mode;\n        }\n        if (additionalParams.padding !== undefined) {\n            this.padding = additionalParams.padding;\n        }\n        if (additionalParams.blockSize !== undefined) {\n            this.blockSize = additionalParams.blockSize;\n        }\n        if (additionalParams.formatter !== undefined) {\n            this.formatter = additionalParams.formatter;\n        }\n        return this;\n    };\n    /**\n     * Converts this cipher params object to a string.\n     *\n     * @throws Error If neither the formatter nor the default formatter is set.\n     *\n     * \\@example\n     *\n     *     let string = cipherParams + '';\n     *     let string = cipherParams.toString();\n     *     let string = cipherParams.toString(CryptoJS.format.OpenSSL);\n     * @param {?=} formatter (Optional) The formatting strategy to use.\n     *\n     * @return {?} The stringified cipher params.\n     *\n     */\n    CipherParams.prototype.toString = /**\n     * Converts this cipher params object to a string.\n     *\n     * @throws Error If neither the formatter nor the default formatter is set.\n     *\n     * \\@example\n     *\n     *     let string = cipherParams + '';\n     *     let string = cipherParams.toString();\n     *     let string = cipherParams.toString(CryptoJS.format.OpenSSL);\n     * @param {?=} formatter (Optional) The formatting strategy to use.\n     *\n     * @return {?} The stringified cipher params.\n     *\n     */\n    function (formatter) {\n        if (formatter) {\n            return formatter.stringify(this);\n        }\n        else if (this.formatter) {\n            return this.formatter.stringify(this);\n        }\n        else {\n            throw new Error('cipher needs a formatter to be able to convert the result into a string');\n        }\n    };\n    return CipherParams;\n}(Base));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar Base64 = /** @class */ (function () {\n    function Base64() {\n    }\n    /**\n     * Converts a word array to a Base64 string.\n     *\n     * \\@example\n     *\n     *     let base64String = Base64.stringify(wordArray);\n     * @param {?} wordArray The word array.\n     *\n     * @return {?} The Base64 string.\n     *\n     */\n    Base64.stringify = /**\n     * Converts a word array to a Base64 string.\n     *\n     * \\@example\n     *\n     *     let base64String = Base64.stringify(wordArray);\n     * @param {?} wordArray The word array.\n     *\n     * @return {?} The Base64 string.\n     *\n     */\n    function (wordArray) {\n        // Clamp excess bits\n        wordArray.clamp();\n        // Convert\n        var /** @type {?} */ base64Chars = [];\n        for (var /** @type {?} */ i = 0; i < wordArray.sigBytes; i += 3) {\n            var /** @type {?} */ byte1 = (wordArray.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n            var /** @type {?} */ byte2 = (wordArray.words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\n            var /** @type {?} */ byte3 = (wordArray.words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\n            var /** @type {?} */ triplet = (byte1 << 16) | (byte2 << 8) | byte3;\n            for (var /** @type {?} */ j = 0; (j < 4) && (i + j * 0.75 < wordArray.sigBytes); j++) {\n                base64Chars.push(this._map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\n            }\n        }\n        // Add padding\n        var /** @type {?} */ paddingChar = this._map.charAt(64);\n        if (paddingChar) {\n            while (base64Chars.length % 4) {\n                base64Chars.push(paddingChar);\n            }\n        }\n        return base64Chars.join('');\n    };\n    /**\n     * Converts a Base64 string to a word array.\n     *\n     * \\@example\n     *\n     *     let wordArray = Base64.parse(base64String);\n     * @param {?} base64Str The Base64 string.\n     *\n     * @return {?} The word array.\n     *\n     */\n    Base64.parse = /**\n     * Converts a Base64 string to a word array.\n     *\n     * \\@example\n     *\n     *     let wordArray = Base64.parse(base64String);\n     * @param {?} base64Str The Base64 string.\n     *\n     * @return {?} The word array.\n     *\n     */\n    function (base64Str) {\n        // Shortcuts\n        var /** @type {?} */ base64StrLength = base64Str.length;\n        if (this._reverseMap === undefined) {\n            this._reverseMap = [];\n            for (var /** @type {?} */ j = 0; j < this._map.length; j++) {\n                this._reverseMap[this._map.charCodeAt(j)] = j;\n            }\n        }\n        // Ignore padding\n        var /** @type {?} */ paddingChar = this._map.charAt(64);\n        if (paddingChar) {\n            var /** @type {?} */ paddingIndex = base64Str.indexOf(paddingChar);\n            if (paddingIndex !== -1) {\n                base64StrLength = paddingIndex;\n            }\n        }\n        // Convert\n        return this.parseLoop(base64Str, base64StrLength, this._reverseMap);\n    };\n    /**\n     * @param {?} base64Str\n     * @param {?} base64StrLength\n     * @param {?} reverseMap\n     * @return {?}\n     */\n    Base64.parseLoop = /**\n     * @param {?} base64Str\n     * @param {?} base64StrLength\n     * @param {?} reverseMap\n     * @return {?}\n     */\n    function (base64Str, base64StrLength, reverseMap) {\n        var /** @type {?} */ words = [];\n        var /** @type {?} */ nBytes = 0;\n        for (var /** @type {?} */ i = 0; i < base64StrLength; i++) {\n            if (i % 4) {\n                var /** @type {?} */ bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\n                var /** @type {?} */ bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\n                words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);\n                nBytes++;\n            }\n        }\n        return new WordArray(words, nBytes);\n    };\n    Base64._map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    Base64._reverseMap = undefined;\n    return Base64;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar OpenSSL = /** @class */ (function () {\n    function OpenSSL() {\n    }\n    /**\n     * Converts a cipher params object to an OpenSSL-compatible string.\n     *\n     * \\@example\n     *\n     *     let openSSLString = OpenSSLFormatter.stringify(cipherParams);\n     * @param {?} cipherParams The cipher params object.\n     *\n     * @return {?} The OpenSSL-compatible string.\n     *\n     */\n    OpenSSL.stringify = /**\n     * Converts a cipher params object to an OpenSSL-compatible string.\n     *\n     * \\@example\n     *\n     *     let openSSLString = OpenSSLFormatter.stringify(cipherParams);\n     * @param {?} cipherParams The cipher params object.\n     *\n     * @return {?} The OpenSSL-compatible string.\n     *\n     */\n    function (cipherParams) {\n        if (!cipherParams.ciphertext) {\n            throw new Error('missing ciphertext in params');\n        }\n        // Shortcuts\n        var /** @type {?} */ ciphertext = cipherParams.ciphertext;\n        var /** @type {?} */ salt = cipherParams.salt;\n        // Format\n        var /** @type {?} */ wordArray;\n        if (salt) {\n            if (typeof salt === 'string') {\n                throw new Error('salt is expected to be a WordArray');\n            }\n            wordArray = (new WordArray([0x53616c74, 0x65645f5f])).concat(salt).concat(ciphertext);\n        }\n        else {\n            wordArray = ciphertext;\n        }\n        return wordArray.toString(Base64);\n    };\n    /**\n     * Converts an OpenSSL-compatible string to a cipher params object.\n     *\n     * \\@example\n     *\n     *     let cipherParams = OpenSSLFormatter.parse(openSSLString);\n     * @param {?} openSSLStr The OpenSSL-compatible string.\n     *\n     * @return {?} The cipher params object.\n     *\n     */\n    OpenSSL.parse = /**\n     * Converts an OpenSSL-compatible string to a cipher params object.\n     *\n     * \\@example\n     *\n     *     let cipherParams = OpenSSLFormatter.parse(openSSLString);\n     * @param {?} openSSLStr The OpenSSL-compatible string.\n     *\n     * @return {?} The cipher params object.\n     *\n     */\n    function (openSSLStr) {\n        // Parse base64\n        var /** @type {?} */ ciphertext = Base64.parse(openSSLStr);\n        // Test for salt\n        var /** @type {?} */ salt;\n        if (ciphertext.words[0] === 0x53616c74 && ciphertext.words[1] === 0x65645f5f) {\n            // Extract salt\n            salt = new WordArray(ciphertext.words.slice(2, 4));\n            // Remove salt from ciphertext\n            ciphertext.words.splice(0, 4);\n            ciphertext.sigBytes -= 16;\n        }\n        return new CipherParams({ ciphertext: ciphertext, salt: salt });\n    };\n    return OpenSSL;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar SerializableCipher = /** @class */ (function () {\n    function SerializableCipher() {\n    }\n    /**\n     * Encrypts a message.\n     *\n     * \\@example\n     *\n     *     let ciphertextParams = SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);\n     *     let ciphertextParams = SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n     *     let ciphertextParams = SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, {\n     *       iv: iv,\n     *       format: CryptoJS.format.OpenSSL\n     *     });\n     * @param {?} cipher The cipher algorithm to use.\n     * @param {?} message The message to encrypt.\n     * @param {?} key The key.\n     * @param {?=} cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return {?} A cipher params object.\n     *\n     */\n    SerializableCipher.encrypt = /**\n     * Encrypts a message.\n     *\n     * \\@example\n     *\n     *     let ciphertextParams = SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);\n     *     let ciphertextParams = SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n     *     let ciphertextParams = SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, {\n     *       iv: iv,\n     *       format: CryptoJS.format.OpenSSL\n     *     });\n     * @param {?} cipher The cipher algorithm to use.\n     * @param {?} message The message to encrypt.\n     * @param {?} key The key.\n     * @param {?=} cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return {?} A cipher params object.\n     *\n     */\n    function (cipher, message, key, cfg) {\n        // Apply config defaults\n        var /** @type {?} */ config = Object.assign({}, this.cfg, cfg);\n        // Encrypt\n        var /** @type {?} */ encryptor = cipher.createEncryptor(key, config);\n        var /** @type {?} */ ciphertext = encryptor.finalize(message);\n        // Create and return serializable cipher params\n        return new CipherParams({\n            ciphertext: ciphertext,\n            key: key,\n            iv: encryptor.cfg.iv,\n            algorithm: cipher,\n            mode: (/** @type {?} */ (encryptor.cfg)).mode,\n            padding: (/** @type {?} */ (encryptor.cfg)).padding,\n            blockSize: encryptor.cfg.blockSize,\n            formatter: config.format\n        });\n    };\n    /**\n     * Decrypts serialized ciphertext.\n     *\n     * \\@example\n     *\n     *     let plaintext = SerializableCipher.decrypt(\n     *         AESAlgorithm,\n     *         formattedCiphertext,\n     *         key, {\n     *             iv: iv,\n     *             format: CryptoJS.format.OpenSSL\n     *         }\n     *     );\n     *\n     *     let plaintext = SerializableCipher.decrypt(\n     *         AESAlgorithm,\n     *         ciphertextParams,\n     *         key, {\n     *             iv: iv,\n     *             format: CryptoJS.format.OpenSSL\n     *         }\n     *     );\n     * @param {?} cipher The cipher algorithm to use.\n     * @param {?} ciphertext The ciphertext to decrypt.\n     * @param {?} key The key.\n     * @param {?=} optionalCfg\n     * @return {?} The plaintext.\n     *\n     */\n    SerializableCipher.decrypt = /**\n     * Decrypts serialized ciphertext.\n     *\n     * \\@example\n     *\n     *     let plaintext = SerializableCipher.decrypt(\n     *         AESAlgorithm,\n     *         formattedCiphertext,\n     *         key, {\n     *             iv: iv,\n     *             format: CryptoJS.format.OpenSSL\n     *         }\n     *     );\n     *\n     *     let plaintext = SerializableCipher.decrypt(\n     *         AESAlgorithm,\n     *         ciphertextParams,\n     *         key, {\n     *             iv: iv,\n     *             format: CryptoJS.format.OpenSSL\n     *         }\n     *     );\n     * @param {?} cipher The cipher algorithm to use.\n     * @param {?} ciphertext The ciphertext to decrypt.\n     * @param {?} key The key.\n     * @param {?=} optionalCfg\n     * @return {?} The plaintext.\n     *\n     */\n    function (cipher, ciphertext, key, optionalCfg) {\n        // Apply config defaults\n        var /** @type {?} */ cfg = Object.assign({}, this.cfg, optionalCfg);\n        if (!cfg.format) {\n            throw new Error('could not determine format');\n        }\n        // Convert string to CipherParams\n        ciphertext = this._parse(ciphertext, cfg.format);\n        if (!ciphertext.ciphertext) {\n            throw new Error('could not determine ciphertext');\n        }\n        // Decrypt\n        var /** @type {?} */ plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);\n        return plaintext;\n    };\n    /**\n     * Converts serialized ciphertext to CipherParams,\n     * else assumed CipherParams already and returns ciphertext unchanged.\n     *\n     * \\@example\n     *\n     *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\n     * @param {?} ciphertext The ciphertext.\n     * @param {?} format The formatting strategy to use to parse serialized ciphertext.\n     *\n     * @return {?} The unserialized ciphertext.\n     *\n     */\n    SerializableCipher._parse = /**\n     * Converts serialized ciphertext to CipherParams,\n     * else assumed CipherParams already and returns ciphertext unchanged.\n     *\n     * \\@example\n     *\n     *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\n     * @param {?} ciphertext The ciphertext.\n     * @param {?} format The formatting strategy to use to parse serialized ciphertext.\n     *\n     * @return {?} The unserialized ciphertext.\n     *\n     */\n    function (ciphertext, format) {\n        if (typeof ciphertext === 'string') {\n            return format.parse(ciphertext);\n        }\n        else {\n            return ciphertext;\n        }\n    };\n    SerializableCipher.cfg = {\n        blockSize: 4,\n        iv: new WordArray([]),\n        format: OpenSSL\n    };\n    return SerializableCipher;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @abstract\n */\nvar  /**\n * @abstract\n */\nHasher = /** @class */ (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(Hasher, _super);\n    function Hasher(cfg) {\n        var _this = \n        // Apply config defaults\n        _super.call(this, Object.assign({\n            blockSize: 512 / 32\n        }, cfg)) || this;\n        // Set initial values\n        // Set initial values\n        _this.reset();\n        return _this;\n    }\n    /**\n     * Creates a shortcut function to a hasher's object interface.\n     *\n     * \\@example\n     *\n     *     let SHA256 = Hasher._createHelper(SHA256);\n     * @param {?} hasher The hasher to create a helper for.\n     *\n     * @return {?} The shortcut function.\n     *\n     */\n    Hasher._createHelper = /**\n     * Creates a shortcut function to a hasher's object interface.\n     *\n     * \\@example\n     *\n     *     let SHA256 = Hasher._createHelper(SHA256);\n     * @param {?} hasher The hasher to create a helper for.\n     *\n     * @return {?} The shortcut function.\n     *\n     */\n    function (hasher) {\n        /**\n         * @param {?} message\n         * @param {?=} cfg\n         * @return {?}\n         */\n        function helper(message, cfg) {\n            var /** @type {?} */ hasherClass = hasher;\n            var /** @type {?} */ hasherInstance = new hasherClass(cfg);\n            return hasherInstance.finalize(message);\n        }\n        return helper;\n    };\n    /**\n     * Updates this hasher with a message.\n     *\n     * @param messageUpdate The message to append.\n     *\n     * @return This hasher.\n     *\n     * @example\n     *\n     *     hasher.update('message');\n     *     hasher.update(wordArray);\n     */\n    /**\n     * Updates this hasher with a message.\n     *\n     * \\@example\n     *\n     *     hasher.update('message');\n     *     hasher.update(wordArray);\n     * @param {?} messageUpdate The message to append.\n     *\n     * @return {?} This hasher.\n     *\n     */\n    Hasher.prototype.update = /**\n     * Updates this hasher with a message.\n     *\n     * \\@example\n     *\n     *     hasher.update('message');\n     *     hasher.update(wordArray);\n     * @param {?} messageUpdate The message to append.\n     *\n     * @return {?} This hasher.\n     *\n     */\n    function (messageUpdate) {\n        // Append\n        this._append(messageUpdate);\n        // Update the hash\n        this._process();\n        // Chainable\n        return this;\n    };\n    /**\n     * Finalizes the hash computation.\n     * Note that the finalize operation is effectively a destructive, read-once operation.\n     *\n     * \\@example\n     *\n     *     let hash = hasher.finalize();\n     *     let hash = hasher.finalize('message');\n     *     let hash = hasher.finalize(wordArray);\n     * @param {?} messageUpdate (Optional) A final message update.\n     *\n     * @return {?} The hash.\n     *\n     */\n    Hasher.prototype.finalize = /**\n     * Finalizes the hash computation.\n     * Note that the finalize operation is effectively a destructive, read-once operation.\n     *\n     * \\@example\n     *\n     *     let hash = hasher.finalize();\n     *     let hash = hasher.finalize('message');\n     *     let hash = hasher.finalize(wordArray);\n     * @param {?} messageUpdate (Optional) A final message update.\n     *\n     * @return {?} The hash.\n     *\n     */\n    function (messageUpdate) {\n        // Final message update\n        if (messageUpdate) {\n            this._append(messageUpdate);\n        }\n        // Perform concrete-hasher logic\n        var /** @type {?} */ hash = this._doFinalize();\n        return hash;\n    };\n    return Hasher;\n}(BufferedBlockAlgorithm));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n// Constants table\nvar /** @type {?} */ T = [];\n// Compute constants\nfor (var /** @type {?} */ i = 0; i < 64; i++) {\n    T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;\n}\nvar MD5 = /** @class */ (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(MD5, _super);\n    function MD5() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} a\n     * @param {?} b\n     * @param {?} c\n     * @param {?} d\n     * @param {?} x\n     * @param {?} s\n     * @param {?} t\n     * @return {?}\n     */\n    MD5.FF = /**\n     * @param {?} a\n     * @param {?} b\n     * @param {?} c\n     * @param {?} d\n     * @param {?} x\n     * @param {?} s\n     * @param {?} t\n     * @return {?}\n     */\n    function (a, b, c, d, x, s, t) {\n        var /** @type {?} */ n = a + ((b & c) | (~b & d)) + x + t;\n        return ((n << s) | (n >>> (32 - s))) + b;\n    };\n    /**\n     * @param {?} a\n     * @param {?} b\n     * @param {?} c\n     * @param {?} d\n     * @param {?} x\n     * @param {?} s\n     * @param {?} t\n     * @return {?}\n     */\n    MD5.GG = /**\n     * @param {?} a\n     * @param {?} b\n     * @param {?} c\n     * @param {?} d\n     * @param {?} x\n     * @param {?} s\n     * @param {?} t\n     * @return {?}\n     */\n    function (a, b, c, d, x, s, t) {\n        var /** @type {?} */ n = a + ((b & d) | (c & ~d)) + x + t;\n        return ((n << s) | (n >>> (32 - s))) + b;\n    };\n    /**\n     * @param {?} a\n     * @param {?} b\n     * @param {?} c\n     * @param {?} d\n     * @param {?} x\n     * @param {?} s\n     * @param {?} t\n     * @return {?}\n     */\n    MD5.HH = /**\n     * @param {?} a\n     * @param {?} b\n     * @param {?} c\n     * @param {?} d\n     * @param {?} x\n     * @param {?} s\n     * @param {?} t\n     * @return {?}\n     */\n    function (a, b, c, d, x, s, t) {\n        var /** @type {?} */ n = a + (b ^ c ^ d) + x + t;\n        return ((n << s) | (n >>> (32 - s))) + b;\n    };\n    /**\n     * @param {?} a\n     * @param {?} b\n     * @param {?} c\n     * @param {?} d\n     * @param {?} x\n     * @param {?} s\n     * @param {?} t\n     * @return {?}\n     */\n    MD5.II = /**\n     * @param {?} a\n     * @param {?} b\n     * @param {?} c\n     * @param {?} d\n     * @param {?} x\n     * @param {?} s\n     * @param {?} t\n     * @return {?}\n     */\n    function (a, b, c, d, x, s, t) {\n        var /** @type {?} */ n = a + (c ^ (b | ~d)) + x + t;\n        return ((n << s) | (n >>> (32 - s))) + b;\n    };\n    /**\n     * @return {?}\n     */\n    MD5.prototype.reset = /**\n     * @return {?}\n     */\n    function () {\n        // reset core values\n        _super.prototype.reset.call(this);\n        this._hash = new WordArray([\n            0x67452301, 0xefcdab89,\n            0x98badcfe, 0x10325476\n        ]);\n    };\n    /**\n     * @param {?} M\n     * @param {?} offset\n     * @return {?}\n     */\n    MD5.prototype._doProcessBlock = /**\n     * @param {?} M\n     * @param {?} offset\n     * @return {?}\n     */\n    function (M, offset) {\n        // Swap endian\n        for (var /** @type {?} */ i = 0; i < 16; i++) {\n            // Shortcuts\n            var /** @type {?} */ offset_i = offset + i;\n            var /** @type {?} */ M_offset_i = M[offset_i];\n            M[offset_i] = ((((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) |\n                (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00));\n        }\n        // Shortcuts\n        var /** @type {?} */ H = this._hash.words;\n        var /** @type {?} */ M_offset_0 = M[offset + 0];\n        var /** @type {?} */ M_offset_1 = M[offset + 1];\n        var /** @type {?} */ M_offset_2 = M[offset + 2];\n        var /** @type {?} */ M_offset_3 = M[offset + 3];\n        var /** @type {?} */ M_offset_4 = M[offset + 4];\n        var /** @type {?} */ M_offset_5 = M[offset + 5];\n        var /** @type {?} */ M_offset_6 = M[offset + 6];\n        var /** @type {?} */ M_offset_7 = M[offset + 7];\n        var /** @type {?} */ M_offset_8 = M[offset + 8];\n        var /** @type {?} */ M_offset_9 = M[offset + 9];\n        var /** @type {?} */ M_offset_10 = M[offset + 10];\n        var /** @type {?} */ M_offset_11 = M[offset + 11];\n        var /** @type {?} */ M_offset_12 = M[offset + 12];\n        var /** @type {?} */ M_offset_13 = M[offset + 13];\n        var /** @type {?} */ M_offset_14 = M[offset + 14];\n        var /** @type {?} */ M_offset_15 = M[offset + 15];\n        // Working variables\n        var /** @type {?} */ a = H[0];\n        var /** @type {?} */ b = H[1];\n        var /** @type {?} */ c = H[2];\n        var /** @type {?} */ d = H[3];\n        // Computation\n        a = MD5.FF(a, b, c, d, M_offset_0, 7, T[0]);\n        d = MD5.FF(d, a, b, c, M_offset_1, 12, T[1]);\n        c = MD5.FF(c, d, a, b, M_offset_2, 17, T[2]);\n        b = MD5.FF(b, c, d, a, M_offset_3, 22, T[3]);\n        a = MD5.FF(a, b, c, d, M_offset_4, 7, T[4]);\n        d = MD5.FF(d, a, b, c, M_offset_5, 12, T[5]);\n        c = MD5.FF(c, d, a, b, M_offset_6, 17, T[6]);\n        b = MD5.FF(b, c, d, a, M_offset_7, 22, T[7]);\n        a = MD5.FF(a, b, c, d, M_offset_8, 7, T[8]);\n        d = MD5.FF(d, a, b, c, M_offset_9, 12, T[9]);\n        c = MD5.FF(c, d, a, b, M_offset_10, 17, T[10]);\n        b = MD5.FF(b, c, d, a, M_offset_11, 22, T[11]);\n        a = MD5.FF(a, b, c, d, M_offset_12, 7, T[12]);\n        d = MD5.FF(d, a, b, c, M_offset_13, 12, T[13]);\n        c = MD5.FF(c, d, a, b, M_offset_14, 17, T[14]);\n        b = MD5.FF(b, c, d, a, M_offset_15, 22, T[15]);\n        a = MD5.GG(a, b, c, d, M_offset_1, 5, T[16]);\n        d = MD5.GG(d, a, b, c, M_offset_6, 9, T[17]);\n        c = MD5.GG(c, d, a, b, M_offset_11, 14, T[18]);\n        b = MD5.GG(b, c, d, a, M_offset_0, 20, T[19]);\n        a = MD5.GG(a, b, c, d, M_offset_5, 5, T[20]);\n        d = MD5.GG(d, a, b, c, M_offset_10, 9, T[21]);\n        c = MD5.GG(c, d, a, b, M_offset_15, 14, T[22]);\n        b = MD5.GG(b, c, d, a, M_offset_4, 20, T[23]);\n        a = MD5.GG(a, b, c, d, M_offset_9, 5, T[24]);\n        d = MD5.GG(d, a, b, c, M_offset_14, 9, T[25]);\n        c = MD5.GG(c, d, a, b, M_offset_3, 14, T[26]);\n        b = MD5.GG(b, c, d, a, M_offset_8, 20, T[27]);\n        a = MD5.GG(a, b, c, d, M_offset_13, 5, T[28]);\n        d = MD5.GG(d, a, b, c, M_offset_2, 9, T[29]);\n        c = MD5.GG(c, d, a, b, M_offset_7, 14, T[30]);\n        b = MD5.GG(b, c, d, a, M_offset_12, 20, T[31]);\n        a = MD5.HH(a, b, c, d, M_offset_5, 4, T[32]);\n        d = MD5.HH(d, a, b, c, M_offset_8, 11, T[33]);\n        c = MD5.HH(c, d, a, b, M_offset_11, 16, T[34]);\n        b = MD5.HH(b, c, d, a, M_offset_14, 23, T[35]);\n        a = MD5.HH(a, b, c, d, M_offset_1, 4, T[36]);\n        d = MD5.HH(d, a, b, c, M_offset_4, 11, T[37]);\n        c = MD5.HH(c, d, a, b, M_offset_7, 16, T[38]);\n        b = MD5.HH(b, c, d, a, M_offset_10, 23, T[39]);\n        a = MD5.HH(a, b, c, d, M_offset_13, 4, T[40]);\n        d = MD5.HH(d, a, b, c, M_offset_0, 11, T[41]);\n        c = MD5.HH(c, d, a, b, M_offset_3, 16, T[42]);\n        b = MD5.HH(b, c, d, a, M_offset_6, 23, T[43]);\n        a = MD5.HH(a, b, c, d, M_offset_9, 4, T[44]);\n        d = MD5.HH(d, a, b, c, M_offset_12, 11, T[45]);\n        c = MD5.HH(c, d, a, b, M_offset_15, 16, T[46]);\n        b = MD5.HH(b, c, d, a, M_offset_2, 23, T[47]);\n        a = MD5.II(a, b, c, d, M_offset_0, 6, T[48]);\n        d = MD5.II(d, a, b, c, M_offset_7, 10, T[49]);\n        c = MD5.II(c, d, a, b, M_offset_14, 15, T[50]);\n        b = MD5.II(b, c, d, a, M_offset_5, 21, T[51]);\n        a = MD5.II(a, b, c, d, M_offset_12, 6, T[52]);\n        d = MD5.II(d, a, b, c, M_offset_3, 10, T[53]);\n        c = MD5.II(c, d, a, b, M_offset_10, 15, T[54]);\n        b = MD5.II(b, c, d, a, M_offset_1, 21, T[55]);\n        a = MD5.II(a, b, c, d, M_offset_8, 6, T[56]);\n        d = MD5.II(d, a, b, c, M_offset_15, 10, T[57]);\n        c = MD5.II(c, d, a, b, M_offset_6, 15, T[58]);\n        b = MD5.II(b, c, d, a, M_offset_13, 21, T[59]);\n        a = MD5.II(a, b, c, d, M_offset_4, 6, T[60]);\n        d = MD5.II(d, a, b, c, M_offset_11, 10, T[61]);\n        c = MD5.II(c, d, a, b, M_offset_2, 15, T[62]);\n        b = MD5.II(b, c, d, a, M_offset_9, 21, T[63]);\n        // Intermediate hash value\n        H[0] = (H[0] + a) | 0;\n        H[1] = (H[1] + b) | 0;\n        H[2] = (H[2] + c) | 0;\n        H[3] = (H[3] + d) | 0;\n    };\n    /**\n     * @return {?}\n     */\n    MD5.prototype._doFinalize = /**\n     * @return {?}\n     */\n    function () {\n        // Shortcuts\n        var /** @type {?} */ data = this._data;\n        var /** @type {?} */ dataWords = data.words;\n        var /** @type {?} */ nBitsTotal = this._nDataBytes * 8;\n        var /** @type {?} */ nBitsLeft = data.sigBytes * 8;\n        // Add padding\n        dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n        var /** @type {?} */ nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\n        var /** @type {?} */ nBitsTotalL = nBitsTotal;\n        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = ((((nBitsTotalH << 8) | (nBitsTotalH >>> 24)) & 0x00ff00ff) |\n            (((nBitsTotalH << 24) | (nBitsTotalH >>> 8)) & 0xff00ff00));\n        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = ((((nBitsTotalL << 8) | (nBitsTotalL >>> 24)) & 0x00ff00ff) |\n            (((nBitsTotalL << 24) | (nBitsTotalL >>> 8)) & 0xff00ff00));\n        data.sigBytes = (dataWords.length + 1) * 4;\n        // Hash final blocks\n        this._process();\n        // Shortcuts\n        var /** @type {?} */ hash = this._hash;\n        var /** @type {?} */ H = hash.words;\n        // Swap endian\n        for (var /** @type {?} */ i = 0; i < 4; i++) {\n            // Shortcut\n            var /** @type {?} */ H_i = H[i];\n            H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) |\n                (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);\n        }\n        // Return final computed hash\n        return hash;\n    };\n    return MD5;\n}(Hasher));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar EvpKDF = /** @class */ (function () {\n    /**\n     * Initializes a newly created key derivation function.\n     *\n     * @param cfg (Optional) The configuration options to use for the derivation.\n     *\n     * @example\n     *\n     *     let kdf = EvpKDF.create();\n     *     let kdf = EvpKDF.create({ keySize: 8 });\n     *     let kdf = EvpKDF.create({ keySize: 8, iterations: 1000 });\n     */\n    function EvpKDF(cfg) {\n        this.cfg = Object.assign({\n            keySize: 128 / 32,\n            hasher: MD5,\n            iterations: 1\n        }, cfg);\n    }\n    /**\n     * Derives a key from a password.\n     *\n     * @param password The password.\n     * @param salt A salt.\n     *\n     * @return The derived key.\n     *\n     * @example\n     *\n     *     let key = kdf.compute(password, salt);\n     */\n    /**\n     * Derives a key from a password.\n     *\n     * \\@example\n     *\n     *     let key = kdf.compute(password, salt);\n     * @param {?} password The password.\n     * @param {?} salt A salt.\n     *\n     * @return {?} The derived key.\n     *\n     */\n    EvpKDF.prototype.compute = /**\n     * Derives a key from a password.\n     *\n     * \\@example\n     *\n     *     let key = kdf.compute(password, salt);\n     * @param {?} password The password.\n     * @param {?} salt A salt.\n     *\n     * @return {?} The derived key.\n     *\n     */\n    function (password, salt) {\n        // Init hasher\n        var /** @type {?} */ hasher = new (/** @type {?} */ (this.cfg.hasher))();\n        // Initial values\n        var /** @type {?} */ derivedKey = new WordArray();\n        // Generate key\n        var /** @type {?} */ block;\n        while (derivedKey.words.length < this.cfg.keySize) {\n            if (block) {\n                hasher.update(block);\n            }\n            block = hasher.update(password).finalize(salt);\n            hasher.reset();\n            // Iterations\n            for (var /** @type {?} */ i = 1; i < this.cfg.iterations; i++) {\n                block = hasher.finalize(block);\n                hasher.reset();\n            }\n            derivedKey.concat(block);\n        }\n        derivedKey.sigBytes = this.cfg.keySize * 4;\n        return derivedKey;\n    };\n    return EvpKDF;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar OpenSSLKdf = /** @class */ (function () {\n    function OpenSSLKdf() {\n    }\n    /**\n     * Derives a key and IV from a password.\n     *\n     * \\@example\n     *\n     *     let derivedParams = OpenSSL.execute('Password', 256/32, 128/32);\n     *     let derivedParams = OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n     * @param {?} password The password to derive from.\n     * @param {?} keySize The size in words of the key to generate.\n     * @param {?} ivSize The size in words of the IV to generate.\n     * @param {?=} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n     *\n     * @return {?} A cipher params object with the key, IV, and salt.\n     *\n     */\n    OpenSSLKdf.execute = /**\n     * Derives a key and IV from a password.\n     *\n     * \\@example\n     *\n     *     let derivedParams = OpenSSL.execute('Password', 256/32, 128/32);\n     *     let derivedParams = OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n     * @param {?} password The password to derive from.\n     * @param {?} keySize The size in words of the key to generate.\n     * @param {?} ivSize The size in words of the IV to generate.\n     * @param {?=} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n     *\n     * @return {?} A cipher params object with the key, IV, and salt.\n     *\n     */\n    function (password, keySize, ivSize, salt) {\n        // Generate random salt\n        if (!salt) {\n            salt = WordArray.random(64 / 8);\n        }\n        // Derive key and IV\n        var /** @type {?} */ key = (new EvpKDF({ keySize: keySize + ivSize })).compute(password, salt);\n        // Separate key and IV\n        var /** @type {?} */ iv = new WordArray(key.words.slice(keySize), ivSize * 4);\n        key.sigBytes = keySize * 4;\n        // Return params\n        return new CipherParams({ key: key, iv: iv, salt: salt });\n    };\n    return OpenSSLKdf;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar PasswordBasedCipher = /** @class */ (function () {\n    function PasswordBasedCipher() {\n    }\n    /**\n     * Encrypts a message using a password.\n     *\n     * \\@example\n     *\n     *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(AES, message, 'password');\n     *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(AES, message, 'password', { format: OpenSSL });\n     * @param {?} cipher The cipher algorithm to use.\n     * @param {?} message The message to encrypt.\n     * @param {?} password The password.\n     * @param {?=} cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return {?} A cipher params object.\n     *\n     */\n    PasswordBasedCipher.encrypt = /**\n     * Encrypts a message using a password.\n     *\n     * \\@example\n     *\n     *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(AES, message, 'password');\n     *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(AES, message, 'password', { format: OpenSSL });\n     * @param {?} cipher The cipher algorithm to use.\n     * @param {?} message The message to encrypt.\n     * @param {?} password The password.\n     * @param {?=} cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return {?} A cipher params object.\n     *\n     */\n    function (cipher, message, password, cfg) {\n        // Apply config defaults\n        var /** @type {?} */ config = Object.assign({}, this.cfg, cfg);\n        // Check if we have a kdf\n        if (config.kdf === undefined) {\n            throw new Error('missing kdf in config');\n        }\n        // Derive key and other params\n        var /** @type {?} */ derivedParams = config.kdf.execute(password, cipher.keySize, cipher.ivSize);\n        // Check if we have an IV\n        if (derivedParams.iv !== undefined) {\n            // Add IV to config\n            config.iv = derivedParams.iv;\n        }\n        // Encrypt\n        var /** @type {?} */ ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, config);\n        // Mix in derived params\n        return ciphertext.extend(derivedParams);\n    };\n    /**\n     * Decrypts serialized ciphertext using a password.\n     *\n     * \\@example\n     *\n     *     var plaintext = PasswordBasedCipher.decrypt(AES, formattedCiphertext, 'password', { format: OpenSSL });\n     *     var plaintext = PasswordBasedCipher.decrypt(AES, ciphertextParams, 'password', { format: OpenSSL });\n     * @param {?} cipher The cipher algorithm to use.\n     * @param {?} ciphertext The ciphertext to decrypt.\n     * @param {?} password The password.\n     * @param {?=} cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return {?} The plaintext.\n     *\n     */\n    PasswordBasedCipher.decrypt = /**\n     * Decrypts serialized ciphertext using a password.\n     *\n     * \\@example\n     *\n     *     var plaintext = PasswordBasedCipher.decrypt(AES, formattedCiphertext, 'password', { format: OpenSSL });\n     *     var plaintext = PasswordBasedCipher.decrypt(AES, ciphertextParams, 'password', { format: OpenSSL });\n     * @param {?} cipher The cipher algorithm to use.\n     * @param {?} ciphertext The ciphertext to decrypt.\n     * @param {?} password The password.\n     * @param {?=} cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return {?} The plaintext.\n     *\n     */\n    function (cipher, ciphertext, password, cfg) {\n        // Apply config defaults\n        var /** @type {?} */ config = Object.assign({}, this.cfg, cfg);\n        // Check if we have a kdf\n        if (config.format === undefined) {\n            throw new Error('missing format in config');\n        }\n        // Convert string to CipherParams\n        ciphertext = this._parse(ciphertext, config.format);\n        // Check if we have a kdf\n        if (config.kdf === undefined) {\n            throw new Error('the key derivation function must be set');\n        }\n        // Derive key and other params\n        var /** @type {?} */ derivedParams = config.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);\n        // Check if we have an IV\n        if (derivedParams.iv !== undefined) {\n            // Add IV to config\n            config.iv = derivedParams.iv;\n        }\n        // Decrypt\n        var /** @type {?} */ plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, config);\n        return plaintext;\n    };\n    /**\n     * Converts serialized ciphertext to CipherParams,\n     * else assumed CipherParams already and returns ciphertext unchanged.\n     *\n     * \\@example\n     *\n     *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\n     * @param {?} ciphertext The ciphertext.\n     * @param {?} format The formatting strategy to use to parse serialized ciphertext.\n     *\n     * @return {?} The unserialized ciphertext.\n     *\n     */\n    PasswordBasedCipher._parse = /**\n     * Converts serialized ciphertext to CipherParams,\n     * else assumed CipherParams already and returns ciphertext unchanged.\n     *\n     * \\@example\n     *\n     *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\n     * @param {?} ciphertext The ciphertext.\n     * @param {?} format The formatting strategy to use to parse serialized ciphertext.\n     *\n     * @return {?} The unserialized ciphertext.\n     *\n     */\n    function (ciphertext, format) {\n        if (typeof ciphertext === 'string') {\n            return format.parse(ciphertext);\n        }\n        else {\n            return ciphertext;\n        }\n    };\n    PasswordBasedCipher.cfg = {\n        blockSize: 4,\n        iv: new WordArray([]),\n        format: OpenSSL,\n        kdf: OpenSSLKdf\n    };\n    return PasswordBasedCipher;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @abstract\n */\nvar Cipher = /** @class */ (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(Cipher, _super);\n    function Cipher(xformMode, key, cfg) {\n        var _this = \n        // Apply config defaults\n        _super.call(this, Object.assign({\n            blockSize: 1\n        }, cfg)) || this;\n        // Store transform mode and key\n        // Store transform mode and key\n        _this._xformMode = xformMode;\n        _this._key = key;\n        // Set initial values\n        // Set initial values\n        _this.reset();\n        return _this;\n    }\n    /**\n     * Creates this cipher in encryption mode.\n     *\n     * \\@example\n     *\n     *     let cipher = AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n     * @param {?} key The key.\n     * @param {?=} cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return {?} A cipher instance.\n     *\n     */\n    Cipher.createEncryptor = /**\n     * Creates this cipher in encryption mode.\n     *\n     * \\@example\n     *\n     *     let cipher = AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n     * @param {?} key The key.\n     * @param {?=} cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return {?} A cipher instance.\n     *\n     */\n    function (key, cfg) {\n        // workaround for typescript not being able to create a abstract creator function directly\n        var /** @type {?} */ thisClass = this;\n        return new thisClass(this._ENC_XFORM_MODE, key, cfg);\n    };\n    /**\n     * Creates this cipher in decryption mode.\n     *\n     * \\@example\n     *\n     *     let cipher = AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n     * @param {?} key The key.\n     * @param {?=} cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return {?} A cipher instance.\n     *\n     */\n    Cipher.createDecryptor = /**\n     * Creates this cipher in decryption mode.\n     *\n     * \\@example\n     *\n     *     let cipher = AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n     * @param {?} key The key.\n     * @param {?=} cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return {?} A cipher instance.\n     *\n     */\n    function (key, cfg) {\n        // workaround for typescript not being able to create a abstract creator function directly\n        var /** @type {?} */ thisClass = this;\n        return new thisClass(this._DEC_XFORM_MODE, key, cfg);\n    };\n    /**\n     * Creates shortcut functions to a cipher's object interface.\n     *\n     * \\@example\n     *\n     *     let AES = Cipher._createHelper(AESAlgorithm);\n     * @param {?} cipher The cipher to create a helper for.\n     *\n     * @return {?} An object with encrypt and decrypt shortcut functions.\n     *\n     */\n    Cipher._createHelper = /**\n     * Creates shortcut functions to a cipher's object interface.\n     *\n     * \\@example\n     *\n     *     let AES = Cipher._createHelper(AESAlgorithm);\n     * @param {?} cipher The cipher to create a helper for.\n     *\n     * @return {?} An object with encrypt and decrypt shortcut functions.\n     *\n     */\n    function (cipher) {\n        /**\n         * @param {?} message\n         * @param {?} key\n         * @param {?=} cfg\n         * @return {?}\n         */\n        function encrypt(message, key, cfg) {\n            if (typeof key === 'string') {\n                return PasswordBasedCipher.encrypt(cipher, message, key, cfg);\n            }\n            else {\n                return SerializableCipher.encrypt(cipher, message, key, cfg);\n            }\n        }\n        /**\n         * @param {?} ciphertext\n         * @param {?} key\n         * @param {?=} cfg\n         * @return {?}\n         */\n        function decrypt(ciphertext, key, cfg) {\n            if (typeof key === 'string') {\n                return PasswordBasedCipher.decrypt(cipher, ciphertext, key, cfg);\n            }\n            else {\n                return SerializableCipher.decrypt(cipher, ciphertext, key, cfg);\n            }\n        }\n        return {\n            encrypt: encrypt,\n            decrypt: decrypt\n        };\n    };\n    /**\n     * Adds data to be encrypted or decrypted.\n     *\n     * \\@example\n     *\n     *     let encrypted = cipher.process('data');\n     *     let encrypted = cipher.process(wordArray);\n     * @param {?} dataUpdate The data to encrypt or decrypt.\n     *\n     * @return {?} The data after processing.\n     *\n     */\n    Cipher.prototype.process = /**\n     * Adds data to be encrypted or decrypted.\n     *\n     * \\@example\n     *\n     *     let encrypted = cipher.process('data');\n     *     let encrypted = cipher.process(wordArray);\n     * @param {?} dataUpdate The data to encrypt or decrypt.\n     *\n     * @return {?} The data after processing.\n     *\n     */\n    function (dataUpdate) {\n        // Append\n        this._append(dataUpdate);\n        // Process available blocks\n        return this._process();\n    };\n    /**\n     * Finalizes the encryption or decryption process.\n     * Note that the finalize operation is effectively a destructive, read-once operation.\n     *\n     * \\@example\n     *\n     *     var encrypted = cipher.finalize();\n     *     var encrypted = cipher.finalize('data');\n     *     var encrypted = cipher.finalize(wordArray);\n     * @param {?=} dataUpdate The final data to encrypt or decrypt.\n     *\n     * @return {?} The data after final processing.\n     *\n     */\n    Cipher.prototype.finalize = /**\n     * Finalizes the encryption or decryption process.\n     * Note that the finalize operation is effectively a destructive, read-once operation.\n     *\n     * \\@example\n     *\n     *     var encrypted = cipher.finalize();\n     *     var encrypted = cipher.finalize('data');\n     *     var encrypted = cipher.finalize(wordArray);\n     * @param {?=} dataUpdate The final data to encrypt or decrypt.\n     *\n     * @return {?} The data after final processing.\n     *\n     */\n    function (dataUpdate) {\n        // Final data update\n        if (dataUpdate) {\n            this._append(dataUpdate);\n        }\n        // Perform concrete-cipher logic\n        var /** @type {?} */ finalProcessedData = this._doFinalize();\n        return finalProcessedData;\n    };\n    /**\n     * A constant representing encryption mode.\n     */\n    Cipher._ENC_XFORM_MODE = 1;\n    /**\n     * A constant representing decryption mode.\n     */\n    Cipher._DEC_XFORM_MODE = 2;\n    /**\n     * This cipher's key size. Default: 4 (128 bits / 32 Bits)\n     */\n    Cipher.keySize = 4;\n    /**\n     * This cipher's IV size. Default: 4 (128 bits / 32 Bits)\n     */\n    Cipher.ivSize = 4;\n    return Cipher;\n}(BufferedBlockAlgorithm));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @abstract\n */\nvar /**\n * @abstract\n */\nBlockCipherModeAlgorithm = /** @class */ (function () {\n    function BlockCipherModeAlgorithm(cipher, iv) {\n        this.init(cipher, iv);\n    }\n    /**\n     * Initializes a newly created mode.\n     *\n     * \\@example\n     *\n     *     var mode = CBC.Encryptor.create(cipher, iv.words);\n     * @param {?} cipher A block cipher instance.\n     * @param {?=} iv The IV words.\n     *\n     * @return {?}\n     */\n    BlockCipherModeAlgorithm.prototype.init = /**\n     * Initializes a newly created mode.\n     *\n     * \\@example\n     *\n     *     var mode = CBC.Encryptor.create(cipher, iv.words);\n     * @param {?} cipher A block cipher instance.\n     * @param {?=} iv The IV words.\n     *\n     * @return {?}\n     */\n    function (cipher, iv) {\n        this._cipher = cipher;\n        this._iv = iv;\n    };\n    return BlockCipherModeAlgorithm;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @abstract\n */\nvar BlockCipherMode = /** @class */ (function () {\n    function BlockCipherMode() {\n    }\n    /**\n     * Creates this mode for encryption.\n     *\n     * \\@example\n     *\n     *     var mode = CBC.createEncryptor(cipher, iv.words);\n     * @param {?} cipher A block cipher instance.\n     * @param {?} iv The IV words.\n     *\n     * @return {?}\n     */\n    BlockCipherMode.createEncryptor = /**\n     * Creates this mode for encryption.\n     *\n     * \\@example\n     *\n     *     var mode = CBC.createEncryptor(cipher, iv.words);\n     * @param {?} cipher A block cipher instance.\n     * @param {?} iv The IV words.\n     *\n     * @return {?}\n     */\n    function (cipher, iv) {\n        // workaround for typescript not being able to create a abstract creator function directly\n        var /** @type {?} */ encryptorClass = this.Encryptor;\n        return new encryptorClass(cipher, iv);\n    };\n    /**\n     * Creates this mode for decryption.\n     *\n     * \\@example\n     *\n     *     var mode = CBC.createDecryptor(cipher, iv.words);\n     * @param {?} cipher A block cipher instance.\n     * @param {?} iv The IV words.\n     *\n     * @return {?}\n     */\n    BlockCipherMode.createDecryptor = /**\n     * Creates this mode for decryption.\n     *\n     * \\@example\n     *\n     *     var mode = CBC.createDecryptor(cipher, iv.words);\n     * @param {?} cipher A block cipher instance.\n     * @param {?} iv The IV words.\n     *\n     * @return {?}\n     */\n    function (cipher, iv) {\n        // workaround for typescript not being able to create a abstract creator function directly\n        var /** @type {?} */ decryptorClass = this.Decryptor;\n        return new decryptorClass(cipher, iv);\n    };\n    BlockCipherMode.Encryptor = BlockCipherModeAlgorithm;\n    BlockCipherMode.Decryptor = BlockCipherModeAlgorithm;\n    return BlockCipherMode;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar CBCEncryptor = /** @class */ (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(CBCEncryptor, _super);\n    function CBCEncryptor() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Processes the data block at offset.\n     *\n     * \\@example\n     *\n     *     mode.processBlock(data.words, offset);\n     * @param {?} words The data words to operate on.\n     * @param {?} offset The offset where the block starts.\n     *\n     * @return {?}\n     */\n    CBCEncryptor.prototype.processBlock = /**\n     * Processes the data block at offset.\n     *\n     * \\@example\n     *\n     *     mode.processBlock(data.words, offset);\n     * @param {?} words The data words to operate on.\n     * @param {?} offset The offset where the block starts.\n     *\n     * @return {?}\n     */\n    function (words, offset) {\n        // Check if we have a blockSize\n        if (this._cipher.cfg.blockSize === undefined) {\n            throw new Error('missing blockSize in cipher config');\n        }\n        // XOR and encrypt\n        this.xorBlock(words, offset, this._cipher.cfg.blockSize);\n        this._cipher.encryptBlock(words, offset);\n        // Remember this block to use with next block\n        this._prevBlock = words.slice(offset, offset + this._cipher.cfg.blockSize);\n    };\n    /**\n     * @param {?} words\n     * @param {?} offset\n     * @param {?} blockSize\n     * @return {?}\n     */\n    CBCEncryptor.prototype.xorBlock = /**\n     * @param {?} words\n     * @param {?} offset\n     * @param {?} blockSize\n     * @return {?}\n     */\n    function (words, offset, blockSize) {\n        // Choose mixing block\n        var /** @type {?} */ block;\n        if (this._iv) {\n            block = this._iv;\n            // Remove IV for subsequent blocks\n            this._iv = undefined;\n        }\n        else {\n            block = this._prevBlock;\n        }\n        // block should never be undefined but we want to make typescript happy\n        if (block !== undefined) {\n            // XOR blocks\n            for (var /** @type {?} */ i = 0; i < blockSize; i++) {\n                words[offset + i] ^= block[i];\n            }\n        }\n    };\n    return CBCEncryptor;\n}(BlockCipherModeAlgorithm));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar CBCDecryptor = /** @class */ (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(CBCDecryptor, _super);\n    function CBCDecryptor() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Processes the data block at offset.\n     *\n     * \\@example\n     *\n     *     mode.processBlock(data.words, offset);\n     * @param {?} words The data words to operate on.\n     * @param {?} offset The offset where the block starts.\n     *\n     * @return {?}\n     */\n    CBCDecryptor.prototype.processBlock = /**\n     * Processes the data block at offset.\n     *\n     * \\@example\n     *\n     *     mode.processBlock(data.words, offset);\n     * @param {?} words The data words to operate on.\n     * @param {?} offset The offset where the block starts.\n     *\n     * @return {?}\n     */\n    function (words, offset) {\n        // Check if we have a blockSize\n        if (this._cipher.cfg.blockSize === undefined) {\n            throw new Error('missing blockSize in cipher config');\n        }\n        // Remember this block to use with next block\n        var /** @type {?} */ thisBlock = words.slice(offset, offset + this._cipher.cfg.blockSize);\n        // Decrypt and XOR\n        this._cipher.decryptBlock(words, offset);\n        this.xorBlock(words, offset, this._cipher.cfg.blockSize);\n        // This block becomes the previous block\n        this._prevBlock = thisBlock;\n    };\n    /**\n     * @param {?} words\n     * @param {?} offset\n     * @param {?} blockSize\n     * @return {?}\n     */\n    CBCDecryptor.prototype.xorBlock = /**\n     * @param {?} words\n     * @param {?} offset\n     * @param {?} blockSize\n     * @return {?}\n     */\n    function (words, offset, blockSize) {\n        // Choose mixing block\n        var /** @type {?} */ block;\n        if (this._iv) {\n            block = this._iv;\n            // Remove IV for subsequent blocks\n            this._iv = undefined;\n        }\n        else {\n            block = this._prevBlock;\n        }\n        // block should never be undefined but we want to make typescript happy\n        if (block !== undefined) {\n            // XOR blocks\n            for (var /** @type {?} */ i = 0; i < blockSize; i++) {\n                words[offset + i] ^= block[i];\n            }\n        }\n    };\n    return CBCDecryptor;\n}(BlockCipherModeAlgorithm));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Cipher Block Chaining mode.\n * @abstract\n */\nvar CBC = /** @class */ (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(CBC, _super);\n    function CBC() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CBC.Encryptor = CBCEncryptor;\n    CBC.Decryptor = CBCDecryptor;\n    return CBC;\n}(BlockCipherMode));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar PKCS7 = /** @class */ (function () {\n    function PKCS7() {\n    }\n    /**\n     * Pads data using the algorithm defined in PKCS #5/7.\n     *\n     * \\@example\n     *\n     *     PKCS7.pad(wordArray, 4);\n     * @param {?} data The data to pad.\n     * @param {?} blockSize The multiple that the data should be padded to.\n     *\n     * @return {?}\n     */\n    PKCS7.pad = /**\n     * Pads data using the algorithm defined in PKCS #5/7.\n     *\n     * \\@example\n     *\n     *     PKCS7.pad(wordArray, 4);\n     * @param {?} data The data to pad.\n     * @param {?} blockSize The multiple that the data should be padded to.\n     *\n     * @return {?}\n     */\n    function (data, blockSize) {\n        // Shortcut\n        var /** @type {?} */ blockSizeBytes = blockSize * 4;\n        // Count padding bytes\n        var /** @type {?} */ nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;\n        // Create padding word\n        var /** @type {?} */ paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;\n        // Create padding\n        var /** @type {?} */ paddingWords = [];\n        for (var /** @type {?} */ i = 0; i < nPaddingBytes; i += 4) {\n            paddingWords.push(paddingWord);\n        }\n        var /** @type {?} */ padding = new WordArray(paddingWords, nPaddingBytes);\n        // Add padding\n        data.concat(padding);\n    };\n    /**\n     * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n     *\n     * \\@example\n     *\n     *     PKCS7.unpad(wordArray);\n     * @param {?} data The data to unpad.\n     *\n     * @return {?}\n     */\n    PKCS7.unpad = /**\n     * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n     *\n     * \\@example\n     *\n     *     PKCS7.unpad(wordArray);\n     * @param {?} data The data to unpad.\n     *\n     * @return {?}\n     */\n    function (data) {\n        // Get number of padding bytes from last byte\n        var /** @type {?} */ nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;\n        // Remove padding\n        data.sigBytes -= nPaddingBytes;\n    };\n    return PKCS7;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @abstract\n */\nvar  /**\n * @abstract\n */\nBlockCipher = /** @class */ (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(BlockCipher, _super);\n    function BlockCipher(xformMode, key, cfg) {\n        return _super.call(this, xformMode, key, Object.assign({\n            // default: 128 / 32\n            blockSize: 4,\n            mode: CBC,\n            padding: PKCS7\n        }, cfg)) || this;\n    }\n    /**\n     * @return {?}\n     */\n    BlockCipher.prototype.reset = /**\n     * @return {?}\n     */\n    function () {\n        // Reset cipher\n        _super.prototype.reset.call(this);\n        // Check if we have a blockSize\n        if (this.cfg.mode === undefined) {\n            throw new Error('missing mode in config');\n        }\n        // Reset block mode\n        var /** @type {?} */ modeCreator;\n        if (this._xformMode === (/** @type {?} */ (this.constructor))._ENC_XFORM_MODE) {\n            modeCreator = this.cfg.mode.createEncryptor;\n        }\n        else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n            modeCreator = this.cfg.mode.createDecryptor;\n            // Keep at least one block in the buffer for unpadding\n            this._minBufferSize = 1;\n        }\n        if (this._mode && this._mode.__creator === modeCreator) {\n            this._mode.init(this, this.cfg.iv && this.cfg.iv.words);\n        }\n        else {\n            this._mode = modeCreator.call(this.cfg.mode, this, this.cfg.iv && this.cfg.iv.words);\n            this._mode.__creator = modeCreator;\n        }\n    };\n    /**\n     * @param {?} words\n     * @param {?} offset\n     * @return {?}\n     */\n    BlockCipher.prototype._doProcessBlock = /**\n     * @param {?} words\n     * @param {?} offset\n     * @return {?}\n     */\n    function (words, offset) {\n        this._mode.processBlock(words, offset);\n    };\n    /**\n     * @return {?}\n     */\n    BlockCipher.prototype._doFinalize = /**\n     * @return {?}\n     */\n    function () {\n        // Check if we have a padding strategy\n        if (this.cfg.padding === undefined) {\n            throw new Error('missing padding in config');\n        }\n        // Finalize\n        var /** @type {?} */ finalProcessedBlocks;\n        if (this._xformMode === (/** @type {?} */ (this.constructor))._ENC_XFORM_MODE) {\n            // Check if we have a blockSize\n            if (this.cfg.blockSize === undefined) {\n                throw new Error('missing blockSize in config');\n            }\n            // Pad data\n            this.cfg.padding.pad(this._data, this.cfg.blockSize);\n            // Process final blocks\n            finalProcessedBlocks = this._process(!!'flush');\n        }\n        else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n            // Process final blocks\n            finalProcessedBlocks = this._process(!!'flush');\n            // Unpad data\n            this.cfg.padding.unpad(finalProcessedBlocks);\n        }\n        return finalProcessedBlocks;\n    };\n    return BlockCipher;\n}(Cipher));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n// Define lookup tables\nvar /** @type {?} */ SBOX = [];\nvar /** @type {?} */ INV_SBOX = [];\nvar /** @type {?} */ SUB_MIX_0 = [];\nvar /** @type {?} */ SUB_MIX_1 = [];\nvar /** @type {?} */ SUB_MIX_2 = [];\nvar /** @type {?} */ SUB_MIX_3 = [];\nvar /** @type {?} */ INV_SUB_MIX_0 = [];\nvar /** @type {?} */ INV_SUB_MIX_1 = [];\nvar /** @type {?} */ INV_SUB_MIX_2 = [];\nvar /** @type {?} */ INV_SUB_MIX_3 = [];\n// Compute lookup tables\n(function () {\n    // Compute double table\n    var /** @type {?} */ d = [];\n    for (var /** @type {?} */ i = 0; i < 256; i++) {\n        if (i < 128) {\n            d[i] = i << 1;\n        }\n        else {\n            d[i] = (i << 1) ^ 0x11b;\n        }\n    }\n    // Walk GF(2^8)\n    var /** @type {?} */ x = 0;\n    var /** @type {?} */ xi = 0;\n    for (var /** @type {?} */ i = 0; i < 256; i++) {\n        // Compute sbox\n        var /** @type {?} */ sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\n        sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\n        SBOX[x] = sx;\n        INV_SBOX[sx] = x;\n        // Compute multiplication\n        var /** @type {?} */ x2 = d[x];\n        var /** @type {?} */ x4 = d[x2];\n        var /** @type {?} */ x8 = d[x4];\n        // Compute sub bytes, mix columns tables\n        var /** @type {?} */ t = (d[sx] * 0x101) ^ (sx * 0x1010100);\n        SUB_MIX_0[x] = (t << 24) | (t >>> 8);\n        SUB_MIX_1[x] = (t << 16) | (t >>> 16);\n        SUB_MIX_2[x] = (t << 8) | (t >>> 24);\n        SUB_MIX_3[x] = t;\n        // Compute inv sub bytes, inv mix columns tables\n        t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n        INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);\n        INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);\n        INV_SUB_MIX_2[sx] = (t << 8) | (t >>> 24);\n        INV_SUB_MIX_3[sx] = t;\n        // Compute next counter\n        if (!x) {\n            x = xi = 1;\n        }\n        else {\n            x = x2 ^ d[d[d[x8 ^ x2]]];\n            xi ^= d[d[xi]];\n        }\n    }\n}());\n// Precomputed Rcon lookup\nvar /** @type {?} */ RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\nvar AES = /** @class */ (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(AES, _super);\n    function AES(xformMode, key, cfg) {\n        return _super.call(this, xformMode, key, cfg) || this;\n    }\n    /**\n     * @return {?}\n     */\n    AES.prototype.reset = /**\n     * @return {?}\n     */\n    function () {\n        // reset core values\n        _super.prototype.reset.call(this);\n        // Skip reset of nRounds has been set before and key did not change\n        if (this._nRounds && this._keyPriorReset === this._key) {\n            return;\n        }\n        // Shortcuts\n        var /** @type {?} */ key = this._keyPriorReset = this._key;\n        var /** @type {?} */ keyWords = key.words;\n        var /** @type {?} */ keySize = key.sigBytes / 4;\n        // Compute number of rounds\n        var /** @type {?} */ nRounds = this._nRounds = keySize + 6;\n        // Compute number of key schedule rows\n        var /** @type {?} */ ksRows = (nRounds + 1) * 4;\n        // Compute key schedule\n        var /** @type {?} */ keySchedule = this._keySchedule = [];\n        for (var /** @type {?} */ ksRow = 0; ksRow < ksRows; ksRow++) {\n            if (ksRow < keySize) {\n                keySchedule[ksRow] = keyWords[ksRow];\n            }\n            else {\n                var /** @type {?} */ t = keySchedule[ksRow - 1];\n                if (!(ksRow % keySize)) {\n                    // Rot word\n                    t = (t << 8) | (t >>> 24);\n                    // Sub word\n                    t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\n                    // Mix Rcon\n                    t ^= RCON[(ksRow / keySize) | 0] << 24;\n                }\n                else if (keySize > 6 && ksRow % keySize === 4) {\n                    // Sub word\n                    t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\n                }\n                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;\n            }\n        }\n        // Compute inv key schedule\n        var /** @type {?} */ invKeySchedule = this._invKeySchedule = [];\n        for (var /** @type {?} */ invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n            var /** @type {?} */ ksRow = ksRows - invKsRow;\n            var /** @type {?} */ t = void 0;\n            if (invKsRow % 4) {\n                t = keySchedule[ksRow];\n            }\n            else {\n                t = keySchedule[ksRow - 4];\n            }\n            if (invKsRow < 4 || ksRow <= 4) {\n                invKeySchedule[invKsRow] = t;\n            }\n            else {\n                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^\n                    INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];\n            }\n        }\n    };\n    /**\n     * @param {?} M\n     * @param {?} offset\n     * @return {?}\n     */\n    AES.prototype.encryptBlock = /**\n     * @param {?} M\n     * @param {?} offset\n     * @return {?}\n     */\n    function (M, offset) {\n        this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);\n    };\n    /**\n     * @param {?} M\n     * @param {?} offset\n     * @return {?}\n     */\n    AES.prototype.decryptBlock = /**\n     * @param {?} M\n     * @param {?} offset\n     * @return {?}\n     */\n    function (M, offset) {\n        // Swap 2nd and 4th rows\n        var /** @type {?} */ t = M[offset + 1];\n        M[offset + 1] = M[offset + 3];\n        M[offset + 3] = t;\n        this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);\n        // Inv swap 2nd and 4th rows\n        t = M[offset + 1];\n        M[offset + 1] = M[offset + 3];\n        M[offset + 3] = t;\n    };\n    /**\n     * @param {?} M\n     * @param {?} offset\n     * @param {?} keySchedule\n     * @param {?} sub_mix_0\n     * @param {?} sub_mix_1\n     * @param {?} sub_mix_2\n     * @param {?} sub_mix_3\n     * @param {?} sbox\n     * @return {?}\n     */\n    AES.prototype._doCryptBlock = /**\n     * @param {?} M\n     * @param {?} offset\n     * @param {?} keySchedule\n     * @param {?} sub_mix_0\n     * @param {?} sub_mix_1\n     * @param {?} sub_mix_2\n     * @param {?} sub_mix_3\n     * @param {?} sbox\n     * @return {?}\n     */\n    function (M, offset, keySchedule, sub_mix_0, sub_mix_1, sub_mix_2, sub_mix_3, sbox) {\n        // Get input, add round key\n        var /** @type {?} */ s0 = M[offset] ^ keySchedule[0];\n        var /** @type {?} */ s1 = M[offset + 1] ^ keySchedule[1];\n        var /** @type {?} */ s2 = M[offset + 2] ^ keySchedule[2];\n        var /** @type {?} */ s3 = M[offset + 3] ^ keySchedule[3];\n        // Key schedule row counter\n        var /** @type {?} */ ksRow = 4;\n        // Rounds\n        for (var /** @type {?} */ round = 1; round < this._nRounds; round++) {\n            // Shift rows, sub bytes, mix columns, add round key\n            var /** @type {?} */ t0 = sub_mix_0[s0 >>> 24] ^ sub_mix_1[(s1 >>> 16) & 0xff] ^ sub_mix_2[(s2 >>> 8) & 0xff] ^ sub_mix_3[s3 & 0xff] ^\n                keySchedule[ksRow++];\n            var /** @type {?} */ t1 = sub_mix_0[s1 >>> 24] ^ sub_mix_1[(s2 >>> 16) & 0xff] ^ sub_mix_2[(s3 >>> 8) & 0xff] ^ sub_mix_3[s0 & 0xff] ^\n                keySchedule[ksRow++];\n            var /** @type {?} */ t2 = sub_mix_0[s2 >>> 24] ^ sub_mix_1[(s3 >>> 16) & 0xff] ^ sub_mix_2[(s0 >>> 8) & 0xff] ^ sub_mix_3[s1 & 0xff] ^\n                keySchedule[ksRow++];\n            var /** @type {?} */ t3 = sub_mix_0[s3 >>> 24] ^ sub_mix_1[(s0 >>> 16) & 0xff] ^ sub_mix_2[(s1 >>> 8) & 0xff] ^ sub_mix_3[s2 & 0xff] ^\n                keySchedule[ksRow++];\n            // Update state\n            s0 = t0;\n            s1 = t1;\n            s2 = t2;\n            s3 = t3;\n        }\n        // Shift rows, sub bytes, add round key\n        var /** @type {?} */ t0g = ((sbox[s0 >>> 24] << 24) | (sbox[(s1 >>> 16) & 0xff] << 16) | (sbox[(s2 >>> 8) & 0xff] << 8) | sbox[s3 & 0xff]) ^\n            keySchedule[ksRow++];\n        var /** @type {?} */ t1g = ((sbox[s1 >>> 24] << 24) | (sbox[(s2 >>> 16) & 0xff] << 16) | (sbox[(s3 >>> 8) & 0xff] << 8) | sbox[s0 & 0xff]) ^\n            keySchedule[ksRow++];\n        var /** @type {?} */ t2g = ((sbox[s2 >>> 24] << 24) | (sbox[(s3 >>> 16) & 0xff] << 16) | (sbox[(s0 >>> 8) & 0xff] << 8) | sbox[s1 & 0xff]) ^\n            keySchedule[ksRow++];\n        var /** @type {?} */ t3g = ((sbox[s3 >>> 24] << 24) | (sbox[(s0 >>> 16) & 0xff] << 16) | (sbox[(s1 >>> 8) & 0xff] << 8) | sbox[s2 & 0xff]) ^\n            keySchedule[ksRow++];\n        // Set output\n        M[offset] = t0g;\n        M[offset + 1] = t1g;\n        M[offset + 2] = t2g;\n        M[offset + 3] = t3g;\n    };\n    AES.keySize = 8;\n    return AES;\n}(BlockCipher));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n// Initialization and round constants tables\nvar /** @type {?} */ H = [];\nvar /** @type {?} */ K = [];\n// Reusable object\nvar /** @type {?} */ W = [];\nvar SHA256 = /** @class */ (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(SHA256, _super);\n    function SHA256() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @return {?}\n     */\n    SHA256.prototype.reset = /**\n     * @return {?}\n     */\n    function () {\n        // reset core values\n        _super.prototype.reset.call(this);\n        this._hash = new WordArray(H.slice(0));\n    };\n    /**\n     * @param {?} M\n     * @param {?} offset\n     * @return {?}\n     */\n    SHA256.prototype._doProcessBlock = /**\n     * @param {?} M\n     * @param {?} offset\n     * @return {?}\n     */\n    function (M, offset) {\n        // Shortcut\n        var /** @type {?} */ Hl = this._hash.words;\n        // Working variables\n        var /** @type {?} */ a = Hl[0];\n        var /** @type {?} */ b = Hl[1];\n        var /** @type {?} */ c = Hl[2];\n        var /** @type {?} */ d = Hl[3];\n        var /** @type {?} */ e = Hl[4];\n        var /** @type {?} */ f = Hl[5];\n        var /** @type {?} */ g = Hl[6];\n        var /** @type {?} */ h = Hl[7];\n        // Computation\n        for (var /** @type {?} */ i = 0; i < 64; i++) {\n            if (i < 16) {\n                W[i] = M[offset + i] | 0;\n            }\n            else {\n                var /** @type {?} */ gamma0x = W[i - 15];\n                var /** @type {?} */ gamma0 = ((gamma0x << 25) | (gamma0x >>> 7)) ^\n                    ((gamma0x << 14) | (gamma0x >>> 18)) ^\n                    (gamma0x >>> 3);\n                var /** @type {?} */ gamma1x = W[i - 2];\n                var /** @type {?} */ gamma1 = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n                    ((gamma1x << 13) | (gamma1x >>> 19)) ^\n                    (gamma1x >>> 10);\n                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n            }\n            var /** @type {?} */ ch = (e & f) ^ (~e & g);\n            var /** @type {?} */ maj = (a & b) ^ (a & c) ^ (b & c);\n            var /** @type {?} */ sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n            var /** @type {?} */ sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7) | (e >>> 25));\n            var /** @type {?} */ t1 = h + sigma1 + ch + K[i] + W[i];\n            var /** @type {?} */ t2 = sigma0 + maj;\n            h = g;\n            g = f;\n            f = e;\n            e = (d + t1) | 0;\n            d = c;\n            c = b;\n            b = a;\n            a = (t1 + t2) | 0;\n        }\n        // Intermediate hash value\n        Hl[0] = (Hl[0] + a) | 0;\n        Hl[1] = (Hl[1] + b) | 0;\n        Hl[2] = (Hl[2] + c) | 0;\n        Hl[3] = (Hl[3] + d) | 0;\n        Hl[4] = (Hl[4] + e) | 0;\n        Hl[5] = (Hl[5] + f) | 0;\n        Hl[6] = (Hl[6] + g) | 0;\n        Hl[7] = (Hl[7] + h) | 0;\n    };\n    /**\n     * @return {?}\n     */\n    SHA256.prototype._doFinalize = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ nBitsTotal = this._nDataBytes * 8;\n        var /** @type {?} */ nBitsLeft = this._data.sigBytes * 8;\n        // Add padding\n        this._data.words[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n        this._data.words[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n        this._data.words[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n        this._data.sigBytes = this._data.words.length * 4;\n        // Hash final blocks\n        this._process();\n        // Return final computed hash\n        return this._hash;\n    };\n    return SHA256;\n}(Hasher));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar NoPadding = /** @class */ (function () {\n    function NoPadding() {\n    }\n    /**\n     * Doesn't pad the data provided.\n     *\n     * \\@example\n     *\n     *     NoPadding.pad(wordArray, 4);\n     * @param {?} data The data to pad.\n     * @param {?} blockSize The multiple that the data should be padded to.\n     *\n     * @return {?}\n     */\n    NoPadding.pad = /**\n     * Doesn't pad the data provided.\n     *\n     * \\@example\n     *\n     *     NoPadding.pad(wordArray, 4);\n     * @param {?} data The data to pad.\n     * @param {?} blockSize The multiple that the data should be padded to.\n     *\n     * @return {?}\n     */\n    function (data, blockSize) {\n    };\n    /**\n     * Doesn't unpad the data provided.\n     *\n     * \\@example\n     *\n     *     NoPadding.unpad(wordArray);\n     * @param {?} data The data to unpad.\n     *\n     * @return {?}\n     */\n    NoPadding.unpad = /**\n     * Doesn't unpad the data provided.\n     *\n     * \\@example\n     *\n     *     NoPadding.unpad(wordArray);\n     * @param {?} data The data to unpad.\n     *\n     * @return {?}\n     */\n    function (data) {\n    };\n    return NoPadding;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar ECBEncryptor = /** @class */ (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(ECBEncryptor, _super);\n    function ECBEncryptor() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Processes the data block at offset.\n     *\n     * \\@example\n     *\n     *     mode.processBlock(data.words, offset);\n     * @param {?} words The data words to operate on.\n     * @param {?} offset The offset where the block starts.\n     *\n     * @return {?}\n     */\n    ECBEncryptor.prototype.processBlock = /**\n     * Processes the data block at offset.\n     *\n     * \\@example\n     *\n     *     mode.processBlock(data.words, offset);\n     * @param {?} words The data words to operate on.\n     * @param {?} offset The offset where the block starts.\n     *\n     * @return {?}\n     */\n    function (words, offset) {\n        this._cipher.encryptBlock(words, offset);\n    };\n    return ECBEncryptor;\n}(BlockCipherModeAlgorithm));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar ECBDecryptor = /** @class */ (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(ECBDecryptor, _super);\n    function ECBDecryptor() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Processes the data block at offset.\n     *\n     * \\@example\n     *\n     *     mode.processBlock(data.words, offset);\n     * @param {?} words The data words to operate on.\n     * @param {?} offset The offset where the block starts.\n     *\n     * @return {?}\n     */\n    ECBDecryptor.prototype.processBlock = /**\n     * Processes the data block at offset.\n     *\n     * \\@example\n     *\n     *     mode.processBlock(data.words, offset);\n     * @param {?} words The data words to operate on.\n     * @param {?} offset The offset where the block starts.\n     *\n     * @return {?}\n     */\n    function (words, offset) {\n        this._cipher.decryptBlock(words, offset);\n    };\n    return ECBDecryptor;\n}(BlockCipherModeAlgorithm));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Cipher Block Chaining mode.\n * @abstract\n */\nvar ECB = /** @class */ (function (_super) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(ECB, _super);\n    function ECB() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ECB.Encryptor = ECBEncryptor;\n    ECB.Decryptor = ECBDecryptor;\n    return ECB;\n}(BlockCipherMode));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar /** @type {?} */ lib = {\n    BlockCipher: BlockCipher,\n    WordArray: WordArray,\n    CipherParams: CipherParams,\n    Hasher: Hasher,\n    SerializableCipher: SerializableCipher,\n    PasswordBasedCipher: PasswordBasedCipher\n};\nvar /** @type {?} */ algo = {\n    AES: AES,\n    SHA256: SHA256\n};\nvar /** @type {?} */ enc = {\n    Utf8: Utf8,\n    Hex: Hex\n};\nvar /** @type {?} */ pad = {\n    NoPadding: NoPadding,\n    PKCS7: PKCS7\n};\nvar /** @type {?} */ mode = {\n    CBC: CBC,\n    ECB: ECB\n};\n// HELPERS /////////////////////////////////////////////////////////////////////////////////////////\nvar /** @type {?} */ AES$1 = lib.BlockCipher._createHelper(algo.AES);\nvar /** @type {?} */ SHA256$1 = lib.Hasher._createHelper(algo.SHA256);\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\n//# sourceMappingURL=crypto-ts.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY3J5cHRvLXRzL2VzbTUvY3J5cHRvLXRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVrQzs7QUFFbEM7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQjtBQUNBLGdCQUFnQixHQUFHO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEI7QUFDQSxnQkFBZ0IsR0FBRztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixHQUFHO0FBQzFCLDRCQUE0QixHQUFHLFVBQVUsd0JBQXdCO0FBQ2pFLDJCQUEyQixHQUFHO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEI7QUFDQSxnQkFBZ0IsR0FBRztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCO0FBQ0EsZ0JBQWdCLEdBQUc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsR0FBRztBQUMxQjtBQUNBLHVCQUF1QixHQUFHO0FBQzFCLDRCQUE0QixHQUFHLFVBQVUsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVB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Q2xCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLHVCQUF1QixHQUFHO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLHVCQUF1QixHQUFHO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLHVCQUF1QixHQUFHO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixHQUFHLFVBQVUsUUFBUTtBQUNqRDtBQUNBLDJCQUEyQixHQUFHO0FBQzlCLDJCQUEyQixHQUFHO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEdBQUc7QUFDMUIsdUJBQXVCLEdBQUc7QUFDMUIsdUJBQXVCLEdBQUc7QUFDMUIsdUJBQXVCLEdBQUc7QUFDMUIsdUJBQXVCLEdBQUc7QUFDMUIsdUJBQXVCLEdBQUc7QUFDMUIsdUJBQXVCLEdBQUc7QUFDMUIsdUJBQXVCLEdBQUc7QUFDMUIsdUJBQXVCLEdBQUc7QUFDMUIsdUJBQXVCLEdBQUc7QUFDMUIsdUJBQXVCLEdBQUc7QUFDMUIsdUJBQXVCLEdBQUc7QUFDMUIsdUJBQXVCLEdBQUc7QUFDMUIsdUJBQXVCLEdBQUc7QUFDMUIsdUJBQXVCLEdBQUc7QUFDMUIsdUJBQXVCLEdBQUc7QUFDMUIsdUJBQXVCLEdBQUc7QUFDMUI7QUFDQSx1QkFBdUIsR0FBRztBQUMxQix1QkFBdUIsR0FBRztBQUMxQix1QkFBdUIsR0FBRztBQUMxQix1QkFBdUIsR0FBRztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsR0FBRztBQUMxQix1QkFBdUIsR0FBRztBQUMx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LGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRzs7QUFFbEI7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCOztBQUVtWTtBQUNuWSIsInNvdXJjZXMiOlsid2VicGFjazovL3F1aXp6ZXJzLy4vbm9kZV9tb2R1bGVzL2NyeXB0by10cy9lc201L2NyeXB0by10cy5qcz83NzRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgY3J5cHRvLXRzXG4gKiBNSVQgbGljZW5zZVxuICovXG5cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gJ3RzbGliJztcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIEhleCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIZXgoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIGhleCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbGV0IGhleFN0cmluZyA9IEhleC5zdHJpbmdpZnkod29yZEFycmF5KTtcbiAgICAgKiBAcGFyYW0gez99IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99IFRoZSBoZXggc3RyaW5nLlxuICAgICAqXG4gICAgICovXG4gICAgSGV4LnN0cmluZ2lmeSA9IC8qKlxuICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIGhleCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbGV0IGhleFN0cmluZyA9IEhleC5zdHJpbmdpZnkod29yZEFycmF5KTtcbiAgICAgKiBAcGFyYW0gez99IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99IFRoZSBoZXggc3RyaW5nLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuICAgICAgICAvLyBDb252ZXJ0XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhleENoYXJzID0gW107XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB3b3JkQXJyYXkuc2lnQnl0ZXM7IGkrKykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYml0ZSA9ICh3b3JkQXJyYXkud29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuICAgICAgICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSA+Pj4gNCkudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgJiAweDBmKS50b1N0cmluZygxNikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhDaGFycy5qb2luKCcnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgaGV4IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbGV0IHdvcmRBcnJheSA9IEhleC5wYXJzZShoZXhTdHJpbmcpO1xuICAgICAqIEBwYXJhbSB7P30gaGV4U3RyIFRoZSBoZXggc3RyaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybiB7P30gVGhlIHdvcmQgYXJyYXkuXG4gICAgICpcbiAgICAgKi9cbiAgICBIZXgucGFyc2UgPSAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIGxldCB3b3JkQXJyYXkgPSBIZXgucGFyc2UoaGV4U3RyaW5nKTtcbiAgICAgKiBAcGFyYW0gez99IGhleFN0ciBUaGUgaGV4IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99IFRoZSB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gKGhleFN0cikge1xuICAgICAgICAvLyBTaG9ydGN1dFxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoZXhTdHJMZW5ndGggPSBoZXhTdHIubGVuZ3RoO1xuICAgICAgICAvLyBDb252ZXJ0XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHdvcmRzID0gW107XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBoZXhTdHJMZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgd29yZHNbaSA+Pj4gM10gfD0gcGFyc2VJbnQoaGV4U3RyLnN1YnN0cihpLCAyKSwgMTYpIDw8ICgyNCAtIChpICUgOCkgKiA0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheSh3b3JkcywgaGV4U3RyTGVuZ3RoIC8gMik7XG4gICAgfTtcbiAgICByZXR1cm4gSGV4O1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIFdvcmRBcnJheSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgd29yZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3b3JkcyAoT3B0aW9uYWwpIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAgICAgKiBAcGFyYW0gc2lnQnl0ZXMgKE9wdGlvbmFsKSBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoZSB3b3Jkcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbGV0IHdvcmRBcnJheSA9IG5ldyBXb3JkQXJyYXkoKTtcbiAgICAgKiAgICAgbGV0IHdvcmRBcnJheSA9IG5ldyBXb3JkQXJyYXkoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddKTtcbiAgICAgKiAgICAgbGV0IHdvcmRBcnJheSA9IG5ldyBXb3JkQXJyYXkoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddLCA2KTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBXb3JkQXJyYXkod29yZHMsIHNpZ0J5dGVzKSB7XG4gICAgICAgIHRoaXMud29yZHMgPSB3b3JkcyB8fCBbXTtcbiAgICAgICAgaWYgKHNpZ0J5dGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSBzaWdCeXRlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSB0aGlzLndvcmRzLmxlbmd0aCAqIDQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHdvcmQgYXJyYXkgZmlsbGVkIHdpdGggcmFuZG9tIGJ5dGVzLlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIGxldCB3b3JkQXJyYXkgPSBXb3JkQXJyYXkucmFuZG9tKDE2KTtcbiAgICAgKiBAcGFyYW0gez99IG5CeXRlcyBUaGUgbnVtYmVyIG9mIHJhbmRvbSBieXRlcyB0byBnZW5lcmF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99IFRoZSByYW5kb20gd29yZCBhcnJheS5cbiAgICAgKlxuICAgICAqL1xuICAgIFdvcmRBcnJheS5yYW5kb20gPSAvKipcbiAgICAgKiBDcmVhdGVzIGEgd29yZCBhcnJheSBmaWxsZWQgd2l0aCByYW5kb20gYnl0ZXMuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbGV0IHdvcmRBcnJheSA9IFdvcmRBcnJheS5yYW5kb20oMTYpO1xuICAgICAqIEBwYXJhbSB7P30gbkJ5dGVzIFRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7P30gVGhlIHJhbmRvbSB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gKG5CeXRlcykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB3b3JkcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByID0gKGZ1bmN0aW9uIChtX3cpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1feiA9IDB4M2FkZTY4YjE7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXNrID0gMHhmZmZmZmZmZjtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbV96ID0gKDB4OTA2OSAqIChtX3ogJiAweEZGRkYpICsgKG1feiA+PiAweDEwKSkgJiBtYXNrO1xuICAgICAgICAgICAgICAgIG1fdyA9ICgweDQ2NTAgKiAobV93ICYgMHhGRkZGKSArIChtX3cgPj4gMHgxMCkpICYgbWFzaztcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSAoKG1feiA8PCAweDEwKSArIG1fdykgJiBtYXNrO1xuICAgICAgICAgICAgICAgIHJlc3VsdCAvPSAweDEwMDAwMDAwMDtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gMC41O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKiAoTWF0aC5yYW5kb20oKSA+IC41ID8gMSA6IC0xKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwLCAvKiogQHR5cGUgez99ICovIHJjYWNoZSA9IHZvaWQgMDsgaSA8IG5CeXRlczsgaSArPSA0KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBfciA9IHIoKHJjYWNoZSB8fCBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDAwMDAwKTtcbiAgICAgICAgICAgIHJjYWNoZSA9IF9yKCkgKiAweDNhZGU2N2I3O1xuICAgICAgICAgICAgd29yZHMucHVzaCgoX3IoKSAqIDB4MTAwMDAwMDAwKSB8IDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5KHdvcmRzLCBuQnl0ZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyB3b3JkIGFycmF5IHRvIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVuY29kZXIgKE9wdGlvbmFsKSBUaGUgZW5jb2Rpbmcgc3RyYXRlZ3kgdG8gdXNlLiBEZWZhdWx0OiBDcnlwdG9KUy5lbmMuSGV4XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFRoZSBzdHJpbmdpZmllZCB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBsZXQgc3RyaW5nID0gd29yZEFycmF5ICsgJyc7XG4gICAgICogICAgIGxldCBzdHJpbmcgPSB3b3JkQXJyYXkudG9TdHJpbmcoKTtcbiAgICAgKiAgICAgbGV0IHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZyhDcnlwdG9KUy5lbmMuVXRmOCk7XG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyB3b3JkIGFycmF5IHRvIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIGxldCBzdHJpbmcgPSB3b3JkQXJyYXkgKyAnJztcbiAgICAgKiAgICAgbGV0IHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZygpO1xuICAgICAqICAgICBsZXQgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcbiAgICAgKiBAcGFyYW0gez89fSBlbmNvZGVyIChPcHRpb25hbCkgVGhlIGVuY29kaW5nIHN0cmF0ZWd5IHRvIHVzZS4gRGVmYXVsdDogQ3J5cHRvSlMuZW5jLkhleFxuICAgICAqXG4gICAgICogQHJldHVybiB7P30gVGhlIHN0cmluZ2lmaWVkIHdvcmQgYXJyYXkuXG4gICAgICpcbiAgICAgKi9cbiAgICBXb3JkQXJyYXkucHJvdG90eXBlLnRvU3RyaW5nID0gLyoqXG4gICAgICogQ29udmVydHMgdGhpcyB3b3JkIGFycmF5IHRvIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIGxldCBzdHJpbmcgPSB3b3JkQXJyYXkgKyAnJztcbiAgICAgKiAgICAgbGV0IHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZygpO1xuICAgICAqICAgICBsZXQgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcbiAgICAgKiBAcGFyYW0gez89fSBlbmNvZGVyIChPcHRpb25hbCkgVGhlIGVuY29kaW5nIHN0cmF0ZWd5IHRvIHVzZS4gRGVmYXVsdDogQ3J5cHRvSlMuZW5jLkhleFxuICAgICAqXG4gICAgICogQHJldHVybiB7P30gVGhlIHN0cmluZ2lmaWVkIHdvcmQgYXJyYXkuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZW5jb2Rlcikge1xuICAgICAgICByZXR1cm4gKGVuY29kZXIgfHwgSGV4KS5zdHJpbmdpZnkodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb25jYXRlbmF0ZXMgYSB3b3JkIGFycmF5IHRvIHRoaXMgd29yZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkgdG8gYXBwZW5kLlxuICAgICAqXG4gICAgICogQHJldHVybiBUaGlzIHdvcmQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHdvcmRBcnJheTEuY29uY2F0KHdvcmRBcnJheTIpO1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIENvbmNhdGVuYXRlcyBhIHdvcmQgYXJyYXkgdG8gdGhpcyB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHdvcmRBcnJheTEuY29uY2F0KHdvcmRBcnJheTIpO1xuICAgICAqIEBwYXJhbSB7P30gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5IHRvIGFwcGVuZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99IFRoaXMgd29yZCBhcnJheS5cbiAgICAgKlxuICAgICAqL1xuICAgIFdvcmRBcnJheS5wcm90b3R5cGUuY29uY2F0ID0gLyoqXG4gICAgICogQ29uY2F0ZW5hdGVzIGEgd29yZCBhcnJheSB0byB0aGlzIHdvcmQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgd29yZEFycmF5MS5jb25jYXQod29yZEFycmF5Mik7XG4gICAgICogQHBhcmFtIHs/fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkgdG8gYXBwZW5kLlxuICAgICAqXG4gICAgICogQHJldHVybiB7P30gVGhpcyB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuICAgICAgICB0aGlzLmNsYW1wKCk7XG4gICAgICAgIC8vIENvbmNhdFxuICAgICAgICBpZiAodGhpcy5zaWdCeXRlcyAlIDQpIHtcbiAgICAgICAgICAgIC8vIENvcHkgb25lIGJ5dGUgYXQgYSB0aW1lXG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgd29yZEFycmF5LnNpZ0J5dGVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aGF0Qnl0ZSA9ICh3b3JkQXJyYXkud29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuICAgICAgICAgICAgICAgIHRoaXMud29yZHNbKHRoaXMuc2lnQnl0ZXMgKyBpKSA+Pj4gMl0gfD0gdGhhdEJ5dGUgPDwgKDI0IC0gKCh0aGlzLnNpZ0J5dGVzICsgaSkgJSA0KSAqIDgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ29weSBvbmUgd29yZCBhdCBhIHRpbWVcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB3b3JkQXJyYXkuc2lnQnl0ZXM7IGkgKz0gNCkge1xuICAgICAgICAgICAgICAgIHRoaXMud29yZHNbKHRoaXMuc2lnQnl0ZXMgKyBpKSA+Pj4gMl0gPSB3b3JkQXJyYXkud29yZHNbaSA+Pj4gMl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaWdCeXRlcyArPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG4gICAgICAgIC8vIENoYWluYWJsZVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgaW5zaWduaWZpY2FudCBiaXRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB3b3JkQXJyYXkuY2xhbXAoKTtcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGluc2lnbmlmaWNhbnQgYml0cy5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB3b3JkQXJyYXkuY2xhbXAoKTtcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdvcmRBcnJheS5wcm90b3R5cGUuY2xhbXAgPSAvKipcbiAgICAgKiBSZW1vdmVzIGluc2lnbmlmaWNhbnQgYml0cy5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB3b3JkQXJyYXkuY2xhbXAoKTtcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQ2xhbXBcbiAgICAgICAgdGhpcy53b3Jkc1t0aGlzLnNpZ0J5dGVzID4+PiAyXSAmPSAweGZmZmZmZmZmIDw8ICgzMiAtICh0aGlzLnNpZ0J5dGVzICUgNCkgKiA4KTtcbiAgICAgICAgdGhpcy53b3Jkcy5sZW5ndGggPSBNYXRoLmNlaWwodGhpcy5zaWdCeXRlcyAvIDQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICogQHJldHVybiBUaGUgY2xvbmUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIGxldCBjbG9uZSA9IHdvcmRBcnJheS5jbG9uZSgpO1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgd29yZCBhcnJheS5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBsZXQgY2xvbmUgPSB3b3JkQXJyYXkuY2xvbmUoKTtcbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgY2xvbmUuXG4gICAgICpcbiAgICAgKi9cbiAgICBXb3JkQXJyYXkucHJvdG90eXBlLmNsb25lID0gLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIGxldCBjbG9uZSA9IHdvcmRBcnJheS5jbG9uZSgpO1xuICAgICAqIEByZXR1cm4gez99IFRoZSBjbG9uZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkodGhpcy53b3Jkcy5zbGljZSgwKSwgdGhpcy5zaWdCeXRlcyk7XG4gICAgfTtcbiAgICByZXR1cm4gV29yZEFycmF5O1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIExhdGluMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMYXRpbjEoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIExhdGluMSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbGV0IGxhdGluMVN0cmluZyA9IExhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KTtcbiAgICAgKiBAcGFyYW0gez99IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99IFRoZSBMYXRpbjEgc3RyaW5nLlxuICAgICAqXG4gICAgICovXG4gICAgTGF0aW4xLnN0cmluZ2lmeSA9IC8qKlxuICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIExhdGluMSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbGV0IGxhdGluMVN0cmluZyA9IExhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KTtcbiAgICAgKiBAcGFyYW0gez99IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99IFRoZSBMYXRpbjEgc3RyaW5nLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuICAgICAgICAvLyBDb252ZXJ0XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxhdGluMUNoYXJzID0gW107XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB3b3JkQXJyYXkuc2lnQnl0ZXM7IGkrKykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYml0ZSA9ICh3b3JkQXJyYXkud29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuICAgICAgICAgICAgbGF0aW4xQ2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJpdGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGF0aW4xQ2hhcnMuam9pbignJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIExhdGluMSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIGxldCB3b3JkQXJyYXkgPSBMYXRpbjEucGFyc2UobGF0aW4xU3RyaW5nKTtcbiAgICAgKiBAcGFyYW0gez99IGxhdGluMVN0ciBUaGUgTGF0aW4xIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99IFRoZSB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICovXG4gICAgTGF0aW4xLnBhcnNlID0gLyoqXG4gICAgICogQ29udmVydHMgYSBMYXRpbjEgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBsZXQgd29yZEFycmF5ID0gTGF0aW4xLnBhcnNlKGxhdGluMVN0cmluZyk7XG4gICAgICogQHBhcmFtIHs/fSBsYXRpbjFTdHIgVGhlIExhdGluMSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgd29yZCBhcnJheS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChsYXRpbjFTdHIpIHtcbiAgICAgICAgLy8gU2hvcnRjdXRcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGF0aW4xU3RyTGVuZ3RoID0gbGF0aW4xU3RyLmxlbmd0aDtcbiAgICAgICAgLy8gQ29udmVydFxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB3b3JkcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgbGF0aW4xU3RyTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHdvcmRzW2kgPj4+IDJdIHw9IChsYXRpbjFTdHIuY2hhckNvZGVBdChpKSAmIDB4ZmYpIDw8ICgyNCAtIChpICUgNCkgKiA4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheSh3b3JkcywgbGF0aW4xU3RyTGVuZ3RoKTtcbiAgICB9O1xuICAgIHJldHVybiBMYXRpbjE7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgVXRmOCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVdGY4KCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtOCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbGV0IHV0ZjhTdHJpbmcgPSBVdGY4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuICAgICAqIEBwYXJhbSB7P30gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICogQHJldHVybiB7P30gVGhlIFVURi04IHN0cmluZy5cbiAgICAgKlxuICAgICAqL1xuICAgIFV0Zjguc3RyaW5naWZ5ID0gLyoqXG4gICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTggc3RyaW5nLlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIGxldCB1dGY4U3RyaW5nID0gVXRmOC5zdHJpbmdpZnkod29yZEFycmF5KTtcbiAgICAgKiBAcGFyYW0gez99IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99IFRoZSBVVEYtOCBzdHJpbmcuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiAod29yZEFycmF5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShMYXRpbjEuc3RyaW5naWZ5KHdvcmRBcnJheSkpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoLyoqIEB0eXBlIHs/fSAqLyBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBVVEYtOCBkYXRhJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgVVRGLTggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBsZXQgd29yZEFycmF5ID0gVXRmOC5wYXJzZSh1dGY4U3RyaW5nKTtcbiAgICAgKiBAcGFyYW0gez99IHV0ZjhTdHIgVGhlIFVURi04IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99IFRoZSB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICovXG4gICAgVXRmOC5wYXJzZSA9IC8qKlxuICAgICAqIENvbnZlcnRzIGEgVVRGLTggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBsZXQgd29yZEFycmF5ID0gVXRmOC5wYXJzZSh1dGY4U3RyaW5nKTtcbiAgICAgKiBAcGFyYW0gez99IHV0ZjhTdHIgVGhlIFVURi04IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99IFRoZSB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gKHV0ZjhTdHIpIHtcbiAgICAgICAgcmV0dXJuIExhdGluMS5wYXJzZSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodXRmOFN0cikpKTtcbiAgICB9O1xuICAgIHJldHVybiBVdGY4O1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyICAvKipcbiAqIEBhYnN0cmFjdFxuICovXG5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0oY2ZnKSB7XG4gICAgICAgIHRoaXMuX21pbkJ1ZmZlclNpemUgPSAwO1xuICAgICAgICB0aGlzLmNmZyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgYmxvY2tTaXplOiAxXG4gICAgICAgIH0sIGNmZyk7XG4gICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXG4gICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgV29yZEFycmF5KCk7XG4gICAgICAgIHRoaXMuX25EYXRhQnl0ZXMgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhpcyBibG9jayBhbGdvcml0aG0ncyBkYXRhIGJ1ZmZlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldCgpO1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGRhdGEgYnVmZmVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQoKTtcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucHJvdG90eXBlLnJlc2V0ID0gLyoqXG4gICAgICogUmVzZXRzIHRoaXMgYmxvY2sgYWxnb3JpdGhtJ3MgZGF0YSBidWZmZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldCgpO1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xuICAgICAgICB0aGlzLl9kYXRhID0gbmV3IFdvcmRBcnJheSgpO1xuICAgICAgICB0aGlzLl9uRGF0YUJ5dGVzID0gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgbmV3IGRhdGEgdG8gdGhpcyBibG9jayBhbGdvcml0aG0ncyBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBhcHBlbmQuIFN0cmluZ3MgYXJlIGNvbnZlcnRlZCB0byBhIFdvcmRBcnJheSB1c2luZyBVVEYtOC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKCdkYXRhJyk7XG4gICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCh3b3JkQXJyYXkpO1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEFkZHMgbmV3IGRhdGEgdG8gdGhpcyBibG9jayBhbGdvcml0aG0ncyBidWZmZXIuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKCdkYXRhJyk7XG4gICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCh3b3JkQXJyYXkpO1xuICAgICAqIEBwYXJhbSB7P30gZGF0YSBUaGUgZGF0YSB0byBhcHBlbmQuIFN0cmluZ3MgYXJlIGNvbnZlcnRlZCB0byBhIFdvcmRBcnJheSB1c2luZyBVVEYtOC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5wcm90b3R5cGUuX2FwcGVuZCA9IC8qKlxuICAgICAqIEFkZHMgbmV3IGRhdGEgdG8gdGhpcyBibG9jayBhbGdvcml0aG0ncyBidWZmZXIuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKCdkYXRhJyk7XG4gICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCh3b3JkQXJyYXkpO1xuICAgICAqIEBwYXJhbSB7P30gZGF0YSBUaGUgZGF0YSB0byBhcHBlbmQuIFN0cmluZ3MgYXJlIGNvbnZlcnRlZCB0byBhIFdvcmRBcnJheSB1c2luZyBVVEYtOC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gV29yZEFycmF5LCBlbHNlIGFzc3VtZSBXb3JkQXJyYXkgYWxyZWFkeVxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkYXRhID0gVXRmOC5wYXJzZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcHBlbmRcbiAgICAgICAgdGhpcy5fZGF0YS5jb25jYXQoZGF0YSk7XG4gICAgICAgIHRoaXMuX25EYXRhQnl0ZXMgKz0gZGF0YS5zaWdCeXRlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyBhdmFpbGFibGUgZGF0YSBibG9ja3MuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIF9kb1Byb2Nlc3NCbG9jayhvZmZzZXQpLCB3aGljaCBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGEgY29uY3JldGUgc3VidHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkb0ZsdXNoIFdoZXRoZXIgYWxsIGJsb2NrcyBhbmQgcGFydGlhbCBibG9ja3Mgc2hvdWxkIGJlIHByb2Nlc3NlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gVGhlIHByb2Nlc3NlZCBkYXRhLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBsZXQgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoKTtcbiAgICAgKiAgICAgbGV0IHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG4gICAgICovXG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIGF2YWlsYWJsZSBkYXRhIGJsb2Nrcy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGludm9rZXMgX2RvUHJvY2Vzc0Jsb2NrKG9mZnNldCksIHdoaWNoIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgYSBjb25jcmV0ZSBzdWJ0eXBlLlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIGxldCBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcygpO1xuICAgICAqICAgICBsZXQgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoISEnZmx1c2gnKTtcbiAgICAgKiBAcGFyYW0gez89fSBkb0ZsdXNoIFdoZXRoZXIgYWxsIGJsb2NrcyBhbmQgcGFydGlhbCBibG9ja3Mgc2hvdWxkIGJlIHByb2Nlc3NlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99IFRoZSBwcm9jZXNzZWQgZGF0YS5cbiAgICAgKlxuICAgICAqL1xuICAgIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucHJvdG90eXBlLl9wcm9jZXNzID0gLyoqXG4gICAgICogUHJvY2Vzc2VzIGF2YWlsYWJsZSBkYXRhIGJsb2Nrcy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGludm9rZXMgX2RvUHJvY2Vzc0Jsb2NrKG9mZnNldCksIHdoaWNoIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgYSBjb25jcmV0ZSBzdWJ0eXBlLlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIGxldCBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcygpO1xuICAgICAqICAgICBsZXQgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoISEnZmx1c2gnKTtcbiAgICAgKiBAcGFyYW0gez89fSBkb0ZsdXNoIFdoZXRoZXIgYWxsIGJsb2NrcyBhbmQgcGFydGlhbCBibG9ja3Mgc2hvdWxkIGJlIHByb2Nlc3NlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99IFRoZSBwcm9jZXNzZWQgZGF0YS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChkb0ZsdXNoKSB7XG4gICAgICAgIGlmICghdGhpcy5jZmcuYmxvY2tTaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgYmxvY2tTaXplIGluIGNvbmZpZycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBibG9ja1NpemVCeXRlcyA9IHRoaXMuY2ZnLmJsb2NrU2l6ZSAqIDQ7XG4gICAgICAgIC8vIENvdW50IGJsb2NrcyByZWFkeVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuQmxvY2tzUmVhZHkgPSB0aGlzLl9kYXRhLnNpZ0J5dGVzIC8gYmxvY2tTaXplQnl0ZXM7XG4gICAgICAgIGlmIChkb0ZsdXNoKSB7XG4gICAgICAgICAgICAvLyBSb3VuZCB1cCB0byBpbmNsdWRlIHBhcnRpYWwgYmxvY2tzXG4gICAgICAgICAgICBuQmxvY2tzUmVhZHkgPSBNYXRoLmNlaWwobkJsb2Nrc1JlYWR5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJvdW5kIGRvd24gdG8gaW5jbHVkZSBvbmx5IGZ1bGwgYmxvY2tzLFxuICAgICAgICAgICAgLy8gbGVzcyB0aGUgbnVtYmVyIG9mIGJsb2NrcyB0aGF0IG11c3QgcmVtYWluIGluIHRoZSBidWZmZXJcbiAgICAgICAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGgubWF4KChuQmxvY2tzUmVhZHkgfCAwKSAtIHRoaXMuX21pbkJ1ZmZlclNpemUsIDApO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvdW50IHdvcmRzIHJlYWR5XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5Xb3Jkc1JlYWR5ID0gbkJsb2Nrc1JlYWR5ICogdGhpcy5jZmcuYmxvY2tTaXplO1xuICAgICAgICAvLyBDb3VudCBieXRlcyByZWFkeVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuQnl0ZXNSZWFkeSA9IE1hdGgubWluKG5Xb3Jkc1JlYWR5ICogNCwgdGhpcy5fZGF0YS5zaWdCeXRlcyk7XG4gICAgICAgIC8vIFByb2Nlc3MgYmxvY2tzXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb2Nlc3NlZFdvcmRzO1xuICAgICAgICBpZiAobldvcmRzUmVhZHkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbldvcmRzUmVhZHk7IG9mZnNldCArPSB0aGlzLmNmZy5ibG9ja1NpemUpIHtcbiAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWFsZ29yaXRobSBsb2dpY1xuICAgICAgICAgICAgICAgIHRoaXMuX2RvUHJvY2Vzc0Jsb2NrKHRoaXMuX2RhdGEud29yZHMsIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgcHJvY2Vzc2VkIHdvcmRzXG4gICAgICAgICAgICBwcm9jZXNzZWRXb3JkcyA9IHRoaXMuX2RhdGEud29yZHMuc3BsaWNlKDAsIG5Xb3Jkc1JlYWR5KTtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuc2lnQnl0ZXMgLT0gbkJ5dGVzUmVhZHk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHByb2Nlc3NlZCB3b3Jkc1xuICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheShwcm9jZXNzZWRXb3JkcywgbkJ5dGVzUmVhZHkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFRoZSBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbGV0IGNsb25lID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5jbG9uZSgpO1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIGxldCBjbG9uZSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uY2xvbmUoKTtcbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgY2xvbmUuXG4gICAgICpcbiAgICAgKi9cbiAgICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnByb3RvdHlwZS5jbG9uZSA9IC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIGxldCBjbG9uZSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uY2xvbmUoKTtcbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgY2xvbmUuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsb25lID0gdGhpcy5jb25zdHJ1Y3RvcigpO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGF0dHIgaW4gdGhpcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgICAgICAgICAgICBjbG9uZVthdHRyXSA9IHRoaXNbYXR0cl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2xvbmUuX2RhdGEgPSB0aGlzLl9kYXRhLmNsb25lKCk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9O1xuICAgIHJldHVybiBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtO1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIEJhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFzZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIEJhc2U7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgQ2lwaGVyUGFyYW1zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDaXBoZXJQYXJhbXMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2lwaGVyUGFyYW1zKGNpcGhlclBhcmFtcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jaXBoZXJ0ZXh0ID0gY2lwaGVyUGFyYW1zLmNpcGhlcnRleHQ7XG4gICAgICAgIF90aGlzLmtleSA9IGNpcGhlclBhcmFtcy5rZXk7XG4gICAgICAgIF90aGlzLml2ID0gY2lwaGVyUGFyYW1zLml2O1xuICAgICAgICBfdGhpcy5zYWx0ID0gY2lwaGVyUGFyYW1zLnNhbHQ7XG4gICAgICAgIF90aGlzLmFsZ29yaXRobSA9IGNpcGhlclBhcmFtcy5hbGdvcml0aG07XG4gICAgICAgIF90aGlzLm1vZGUgPSBjaXBoZXJQYXJhbXMubW9kZTtcbiAgICAgICAgX3RoaXMucGFkZGluZyA9IGNpcGhlclBhcmFtcy5wYWRkaW5nO1xuICAgICAgICBfdGhpcy5ibG9ja1NpemUgPSBjaXBoZXJQYXJhbXMuYmxvY2tTaXplO1xuICAgICAgICBfdGhpcy5mb3JtYXR0ZXIgPSBjaXBoZXJQYXJhbXMuZm9ybWF0dGVyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYWRkaXRpb25hbFBhcmFtc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2lwaGVyUGFyYW1zLnByb3RvdHlwZS5leHRlbmQgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGFkZGl0aW9uYWxQYXJhbXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChhZGRpdGlvbmFsUGFyYW1zKSB7XG4gICAgICAgIGlmIChhZGRpdGlvbmFsUGFyYW1zLmNpcGhlcnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jaXBoZXJ0ZXh0ID0gYWRkaXRpb25hbFBhcmFtcy5jaXBoZXJ0ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRpdGlvbmFsUGFyYW1zLmtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmtleSA9IGFkZGl0aW9uYWxQYXJhbXMua2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRpdGlvbmFsUGFyYW1zLml2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXYgPSBhZGRpdGlvbmFsUGFyYW1zLml2O1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRpdGlvbmFsUGFyYW1zLnNhbHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zYWx0ID0gYWRkaXRpb25hbFBhcmFtcy5zYWx0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRpdGlvbmFsUGFyYW1zLmFsZ29yaXRobSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFsZ29yaXRobSA9IGFkZGl0aW9uYWxQYXJhbXMuYWxnb3JpdGhtO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRpdGlvbmFsUGFyYW1zLm1vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gYWRkaXRpb25hbFBhcmFtcy5tb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRpdGlvbmFsUGFyYW1zLnBhZGRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wYWRkaW5nID0gYWRkaXRpb25hbFBhcmFtcy5wYWRkaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRpdGlvbmFsUGFyYW1zLmJsb2NrU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmJsb2NrU2l6ZSA9IGFkZGl0aW9uYWxQYXJhbXMuYmxvY2tTaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRpdGlvbmFsUGFyYW1zLmZvcm1hdHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdHRlciA9IGFkZGl0aW9uYWxQYXJhbXMuZm9ybWF0dGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEB0aHJvd3MgRXJyb3IgSWYgbmVpdGhlciB0aGUgZm9ybWF0dGVyIG5vciB0aGUgZGVmYXVsdCBmb3JtYXR0ZXIgaXMgc2V0LlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIGxldCBzdHJpbmcgPSBjaXBoZXJQYXJhbXMgKyAnJztcbiAgICAgKiAgICAgbGV0IHN0cmluZyA9IGNpcGhlclBhcmFtcy50b1N0cmluZygpO1xuICAgICAqICAgICBsZXQgc3RyaW5nID0gY2lwaGVyUGFyYW1zLnRvU3RyaW5nKENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMKTtcbiAgICAgKiBAcGFyYW0gez89fSBmb3JtYXR0ZXIgKE9wdGlvbmFsKSBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byB1c2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgc3RyaW5naWZpZWQgY2lwaGVyIHBhcmFtcy5cbiAgICAgKlxuICAgICAqL1xuICAgIENpcGhlclBhcmFtcy5wcm90b3R5cGUudG9TdHJpbmcgPSAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHRocm93cyBFcnJvciBJZiBuZWl0aGVyIHRoZSBmb3JtYXR0ZXIgbm9yIHRoZSBkZWZhdWx0IGZvcm1hdHRlciBpcyBzZXQuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbGV0IHN0cmluZyA9IGNpcGhlclBhcmFtcyArICcnO1xuICAgICAqICAgICBsZXQgc3RyaW5nID0gY2lwaGVyUGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgICogICAgIGxldCBzdHJpbmcgPSBjaXBoZXJQYXJhbXMudG9TdHJpbmcoQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wpO1xuICAgICAqIEBwYXJhbSB7Pz19IGZvcm1hdHRlciAoT3B0aW9uYWwpIFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIHVzZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99IFRoZSBzdHJpbmdpZmllZCBjaXBoZXIgcGFyYW1zLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gKGZvcm1hdHRlcikge1xuICAgICAgICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVyLnN0cmluZ2lmeSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmZvcm1hdHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVyLnN0cmluZ2lmeSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2lwaGVyIG5lZWRzIGEgZm9ybWF0dGVyIHRvIGJlIGFibGUgdG8gY29udmVydCB0aGUgcmVzdWx0IGludG8gYSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENpcGhlclBhcmFtcztcbn0oQmFzZSkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgQmFzZTY0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhc2U2NCgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgQmFzZTY0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBsZXQgYmFzZTY0U3RyaW5nID0gQmFzZTY0LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuICAgICAqIEBwYXJhbSB7P30gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICogQHJldHVybiB7P30gVGhlIEJhc2U2NCBzdHJpbmcuXG4gICAgICpcbiAgICAgKi9cbiAgICBCYXNlNjQuc3RyaW5naWZ5ID0gLyoqXG4gICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgQmFzZTY0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBsZXQgYmFzZTY0U3RyaW5nID0gQmFzZTY0LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuICAgICAqIEBwYXJhbSB7P30gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICogQHJldHVybiB7P30gVGhlIEJhc2U2NCBzdHJpbmcuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiAod29yZEFycmF5KSB7XG4gICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG4gICAgICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuICAgICAgICAvLyBDb252ZXJ0XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2U2NENoYXJzID0gW107XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB3b3JkQXJyYXkuc2lnQnl0ZXM7IGkgKz0gMykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYnl0ZTEgPSAod29yZEFycmF5LndvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJ5dGUyID0gKHdvcmRBcnJheS53b3Jkc1soaSArIDEpID4+PiAyXSA+Pj4gKDI0IC0gKChpICsgMSkgJSA0KSAqIDgpKSAmIDB4ZmY7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBieXRlMyA9ICh3b3JkQXJyYXkud29yZHNbKGkgKyAyKSA+Pj4gMl0gPj4+ICgyNCAtICgoaSArIDIpICUgNCkgKiA4KSkgJiAweGZmO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJpcGxldCA9IChieXRlMSA8PCAxNikgfCAoYnl0ZTIgPDwgOCkgfCBieXRlMztcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaiA9IDA7IChqIDwgNCkgJiYgKGkgKyBqICogMC43NSA8IHdvcmRBcnJheS5zaWdCeXRlcyk7IGorKykge1xuICAgICAgICAgICAgICAgIGJhc2U2NENoYXJzLnB1c2godGhpcy5fbWFwLmNoYXJBdCgodHJpcGxldCA+Pj4gKDYgKiAoMyAtIGopKSkgJiAweDNmKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHBhZGRpbmdcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFkZGluZ0NoYXIgPSB0aGlzLl9tYXAuY2hhckF0KDY0KTtcbiAgICAgICAgaWYgKHBhZGRpbmdDaGFyKSB7XG4gICAgICAgICAgICB3aGlsZSAoYmFzZTY0Q2hhcnMubGVuZ3RoICUgNCkge1xuICAgICAgICAgICAgICAgIGJhc2U2NENoYXJzLnB1c2gocGFkZGluZ0NoYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlNjRDaGFycy5qb2luKCcnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgQmFzZTY0IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbGV0IHdvcmRBcnJheSA9IEJhc2U2NC5wYXJzZShiYXNlNjRTdHJpbmcpO1xuICAgICAqIEBwYXJhbSB7P30gYmFzZTY0U3RyIFRoZSBCYXNlNjQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybiB7P30gVGhlIHdvcmQgYXJyYXkuXG4gICAgICpcbiAgICAgKi9cbiAgICBCYXNlNjQucGFyc2UgPSAvKipcbiAgICAgKiBDb252ZXJ0cyBhIEJhc2U2NCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIGxldCB3b3JkQXJyYXkgPSBCYXNlNjQucGFyc2UoYmFzZTY0U3RyaW5nKTtcbiAgICAgKiBAcGFyYW0gez99IGJhc2U2NFN0ciBUaGUgQmFzZTY0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99IFRoZSB3b3JkIGFycmF5LlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gKGJhc2U2NFN0cikge1xuICAgICAgICAvLyBTaG9ydGN1dHNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZTY0U3RyTGVuZ3RoID0gYmFzZTY0U3RyLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX3JldmVyc2VNYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fcmV2ZXJzZU1hcCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBqID0gMDsgaiA8IHRoaXMuX21hcC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JldmVyc2VNYXBbdGhpcy5fbWFwLmNoYXJDb2RlQXQoaildID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZ25vcmUgcGFkZGluZ1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYWRkaW5nQ2hhciA9IHRoaXMuX21hcC5jaGFyQXQoNjQpO1xuICAgICAgICBpZiAocGFkZGluZ0NoYXIpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhZGRpbmdJbmRleCA9IGJhc2U2NFN0ci5pbmRleE9mKHBhZGRpbmdDaGFyKTtcbiAgICAgICAgICAgIGlmIChwYWRkaW5nSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYmFzZTY0U3RyTGVuZ3RoID0gcGFkZGluZ0luZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMb29wKGJhc2U2NFN0ciwgYmFzZTY0U3RyTGVuZ3RoLCB0aGlzLl9yZXZlcnNlTWFwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYmFzZTY0U3RyXG4gICAgICogQHBhcmFtIHs/fSBiYXNlNjRTdHJMZW5ndGhcbiAgICAgKiBAcGFyYW0gez99IHJldmVyc2VNYXBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJhc2U2NC5wYXJzZUxvb3AgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGJhc2U2NFN0clxuICAgICAqIEBwYXJhbSB7P30gYmFzZTY0U3RyTGVuZ3RoXG4gICAgICogQHBhcmFtIHs/fSByZXZlcnNlTWFwXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoYmFzZTY0U3RyLCBiYXNlNjRTdHJMZW5ndGgsIHJldmVyc2VNYXApIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd29yZHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbkJ5dGVzID0gMDtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGJhc2U2NFN0ckxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSAlIDQpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiaXRzMSA9IHJldmVyc2VNYXBbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSAtIDEpXSA8PCAoKGkgJSA0KSAqIDIpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJpdHMyID0gcmV2ZXJzZU1hcFtiYXNlNjRTdHIuY2hhckNvZGVBdChpKV0gPj4+ICg2IC0gKGkgJSA0KSAqIDIpO1xuICAgICAgICAgICAgICAgIHdvcmRzW25CeXRlcyA+Pj4gMl0gfD0gKGJpdHMxIHwgYml0czIpIDw8ICgyNCAtIChuQnl0ZXMgJSA0KSAqIDgpO1xuICAgICAgICAgICAgICAgIG5CeXRlcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5KHdvcmRzLCBuQnl0ZXMpO1xuICAgIH07XG4gICAgQmFzZTY0Ll9tYXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuICAgIEJhc2U2NC5fcmV2ZXJzZU1hcCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gQmFzZTY0O1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIE9wZW5TU0wgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3BlblNTTCgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhbiBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIGxldCBvcGVuU1NMU3RyaW5nID0gT3BlblNTTEZvcm1hdHRlci5zdHJpbmdpZnkoY2lwaGVyUGFyYW1zKTtcbiAgICAgKiBAcGFyYW0gez99IGNpcGhlclBhcmFtcyBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cbiAgICAgKlxuICAgICAqL1xuICAgIE9wZW5TU0wuc3RyaW5naWZ5ID0gLyoqXG4gICAgICogQ29udmVydHMgYSBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhbiBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIGxldCBvcGVuU1NMU3RyaW5nID0gT3BlblNTTEZvcm1hdHRlci5zdHJpbmdpZnkoY2lwaGVyUGFyYW1zKTtcbiAgICAgKiBAcGFyYW0gez99IGNpcGhlclBhcmFtcyBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChjaXBoZXJQYXJhbXMpIHtcbiAgICAgICAgaWYgKCFjaXBoZXJQYXJhbXMuY2lwaGVydGV4dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGNpcGhlcnRleHQgaW4gcGFyYW1zJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNpcGhlcnRleHQgPSBjaXBoZXJQYXJhbXMuY2lwaGVydGV4dDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2FsdCA9IGNpcGhlclBhcmFtcy5zYWx0O1xuICAgICAgICAvLyBGb3JtYXRcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd29yZEFycmF5O1xuICAgICAgICBpZiAoc2FsdCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzYWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2FsdCBpcyBleHBlY3RlZCB0byBiZSBhIFdvcmRBcnJheScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29yZEFycmF5ID0gKG5ldyBXb3JkQXJyYXkoWzB4NTM2MTZjNzQsIDB4NjU2NDVmNWZdKSkuY29uY2F0KHNhbHQpLmNvbmNhdChjaXBoZXJ0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdvcmRBcnJheSA9IGNpcGhlcnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdvcmRBcnJheS50b1N0cmluZyhCYXNlNjQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZyB0byBhIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIGxldCBjaXBoZXJQYXJhbXMgPSBPcGVuU1NMRm9ybWF0dGVyLnBhcnNlKG9wZW5TU0xTdHJpbmcpO1xuICAgICAqIEBwYXJhbSB7P30gb3BlblNTTFN0ciBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99IFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cbiAgICAgKlxuICAgICAqL1xuICAgIE9wZW5TU0wucGFyc2UgPSAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nIHRvIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbGV0IGNpcGhlclBhcmFtcyA9IE9wZW5TU0xGb3JtYXR0ZXIucGFyc2Uob3BlblNTTFN0cmluZyk7XG4gICAgICogQHBhcmFtIHs/fSBvcGVuU1NMU3RyIFRoZSBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybiB7P30gVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gKG9wZW5TU0xTdHIpIHtcbiAgICAgICAgLy8gUGFyc2UgYmFzZTY0XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNpcGhlcnRleHQgPSBCYXNlNjQucGFyc2Uob3BlblNTTFN0cik7XG4gICAgICAgIC8vIFRlc3QgZm9yIHNhbHRcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2FsdDtcbiAgICAgICAgaWYgKGNpcGhlcnRleHQud29yZHNbMF0gPT09IDB4NTM2MTZjNzQgJiYgY2lwaGVydGV4dC53b3Jkc1sxXSA9PT0gMHg2NTY0NWY1Zikge1xuICAgICAgICAgICAgLy8gRXh0cmFjdCBzYWx0XG4gICAgICAgICAgICBzYWx0ID0gbmV3IFdvcmRBcnJheShjaXBoZXJ0ZXh0LndvcmRzLnNsaWNlKDIsIDQpKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBzYWx0IGZyb20gY2lwaGVydGV4dFxuICAgICAgICAgICAgY2lwaGVydGV4dC53b3Jkcy5zcGxpY2UoMCwgNCk7XG4gICAgICAgICAgICBjaXBoZXJ0ZXh0LnNpZ0J5dGVzIC09IDE2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2lwaGVyUGFyYW1zKHsgY2lwaGVydGV4dDogY2lwaGVydGV4dCwgc2FsdDogc2FsdCB9KTtcbiAgICB9O1xuICAgIHJldHVybiBPcGVuU1NMO1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIFNlcmlhbGl6YWJsZUNpcGhlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXJpYWxpemFibGVDaXBoZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY3J5cHRzIGEgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBsZXQgY2lwaGVydGV4dFBhcmFtcyA9IFNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXkpO1xuICAgICAqICAgICBsZXQgY2lwaGVydGV4dFBhcmFtcyA9IFNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXksIHsgaXY6IGl2IH0pO1xuICAgICAqICAgICBsZXQgY2lwaGVydGV4dFBhcmFtcyA9IFNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXksIHtcbiAgICAgKiAgICAgICBpdjogaXYsXG4gICAgICogICAgICAgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTFxuICAgICAqICAgICB9KTtcbiAgICAgKiBAcGFyYW0gez99IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGVuY3J5cHQuXG4gICAgICogQHBhcmFtIHs/fSBrZXkgVGhlIGtleS5cbiAgICAgKiBAcGFyYW0gez89fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuICAgICAqXG4gICAgICovXG4gICAgU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQgPSAvKipcbiAgICAgKiBFbmNyeXB0cyBhIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbGV0IGNpcGhlcnRleHRQYXJhbXMgPSBTZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5KTtcbiAgICAgKiAgICAgbGV0IGNpcGhlcnRleHRQYXJhbXMgPSBTZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5LCB7IGl2OiBpdiB9KTtcbiAgICAgKiAgICAgbGV0IGNpcGhlcnRleHRQYXJhbXMgPSBTZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5LCB7XG4gICAgICogICAgICAgaXY6IGl2LFxuICAgICAqICAgICAgIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0xcbiAgICAgKiAgICAgfSk7XG4gICAgICogQHBhcmFtIHs/fSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBlbmNyeXB0LlxuICAgICAqIEBwYXJhbSB7P30ga2V5IFRoZSBrZXkuXG4gICAgICogQHBhcmFtIHs/PX0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7P30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChjaXBoZXIsIG1lc3NhZ2UsIGtleSwgY2ZnKSB7XG4gICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNmZywgY2ZnKTtcbiAgICAgICAgLy8gRW5jcnlwdFxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbmNyeXB0b3IgPSBjaXBoZXIuY3JlYXRlRW5jcnlwdG9yKGtleSwgY29uZmlnKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2lwaGVydGV4dCA9IGVuY3J5cHRvci5maW5hbGl6ZShtZXNzYWdlKTtcbiAgICAgICAgLy8gQ3JlYXRlIGFuZCByZXR1cm4gc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXNcbiAgICAgICAgcmV0dXJuIG5ldyBDaXBoZXJQYXJhbXMoe1xuICAgICAgICAgICAgY2lwaGVydGV4dDogY2lwaGVydGV4dCxcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgaXY6IGVuY3J5cHRvci5jZmcuaXYsXG4gICAgICAgICAgICBhbGdvcml0aG06IGNpcGhlcixcbiAgICAgICAgICAgIG1vZGU6ICgvKiogQHR5cGUgez99ICovIChlbmNyeXB0b3IuY2ZnKSkubW9kZSxcbiAgICAgICAgICAgIHBhZGRpbmc6ICgvKiogQHR5cGUgez99ICovIChlbmNyeXB0b3IuY2ZnKSkucGFkZGluZyxcbiAgICAgICAgICAgIGJsb2NrU2l6ZTogZW5jcnlwdG9yLmNmZy5ibG9ja1NpemUsXG4gICAgICAgICAgICBmb3JtYXR0ZXI6IGNvbmZpZy5mb3JtYXRcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWNyeXB0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbGV0IHBsYWludGV4dCA9IFNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KFxuICAgICAqICAgICAgICAgQUVTQWxnb3JpdGhtLFxuICAgICAqICAgICAgICAgZm9ybWF0dGVkQ2lwaGVydGV4dCxcbiAgICAgKiAgICAgICAgIGtleSwge1xuICAgICAqICAgICAgICAgICAgIGl2OiBpdixcbiAgICAgKiAgICAgICAgICAgICBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMXG4gICAgICogICAgICAgICB9XG4gICAgICogICAgICk7XG4gICAgICpcbiAgICAgKiAgICAgbGV0IHBsYWludGV4dCA9IFNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KFxuICAgICAqICAgICAgICAgQUVTQWxnb3JpdGhtLFxuICAgICAqICAgICAgICAgY2lwaGVydGV4dFBhcmFtcyxcbiAgICAgKiAgICAgICAgIGtleSwge1xuICAgICAqICAgICAgICAgICAgIGl2OiBpdixcbiAgICAgKiAgICAgICAgICAgICBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMXG4gICAgICogICAgICAgICB9XG4gICAgICogICAgICk7XG4gICAgICogQHBhcmFtIHs/fSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7P30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dCB0byBkZWNyeXB0LlxuICAgICAqIEBwYXJhbSB7P30ga2V5IFRoZSBrZXkuXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uYWxDZmdcbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgcGxhaW50ZXh0LlxuICAgICAqXG4gICAgICovXG4gICAgU2VyaWFsaXphYmxlQ2lwaGVyLmRlY3J5cHQgPSAvKipcbiAgICAgKiBEZWNyeXB0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbGV0IHBsYWludGV4dCA9IFNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KFxuICAgICAqICAgICAgICAgQUVTQWxnb3JpdGhtLFxuICAgICAqICAgICAgICAgZm9ybWF0dGVkQ2lwaGVydGV4dCxcbiAgICAgKiAgICAgICAgIGtleSwge1xuICAgICAqICAgICAgICAgICAgIGl2OiBpdixcbiAgICAgKiAgICAgICAgICAgICBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMXG4gICAgICogICAgICAgICB9XG4gICAgICogICAgICk7XG4gICAgICpcbiAgICAgKiAgICAgbGV0IHBsYWludGV4dCA9IFNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KFxuICAgICAqICAgICAgICAgQUVTQWxnb3JpdGhtLFxuICAgICAqICAgICAgICAgY2lwaGVydGV4dFBhcmFtcyxcbiAgICAgKiAgICAgICAgIGtleSwge1xuICAgICAqICAgICAgICAgICAgIGl2OiBpdixcbiAgICAgKiAgICAgICAgICAgICBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMXG4gICAgICogICAgICAgICB9XG4gICAgICogICAgICk7XG4gICAgICogQHBhcmFtIHs/fSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7P30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dCB0byBkZWNyeXB0LlxuICAgICAqIEBwYXJhbSB7P30ga2V5IFRoZSBrZXkuXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uYWxDZmdcbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgcGxhaW50ZXh0LlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gKGNpcGhlciwgY2lwaGVydGV4dCwga2V5LCBvcHRpb25hbENmZykge1xuICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2ZnID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jZmcsIG9wdGlvbmFsQ2ZnKTtcbiAgICAgICAgaWYgKCFjZmcuZm9ybWF0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCBkZXRlcm1pbmUgZm9ybWF0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gQ2lwaGVyUGFyYW1zXG4gICAgICAgIGNpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShjaXBoZXJ0ZXh0LCBjZmcuZm9ybWF0KTtcbiAgICAgICAgaWYgKCFjaXBoZXJ0ZXh0LmNpcGhlcnRleHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IGRldGVybWluZSBjaXBoZXJ0ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVjcnlwdFxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGFpbnRleHQgPSBjaXBoZXIuY3JlYXRlRGVjcnlwdG9yKGtleSwgY2ZnKS5maW5hbGl6ZShjaXBoZXJ0ZXh0LmNpcGhlcnRleHQpO1xuICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0IHRvIENpcGhlclBhcmFtcyxcbiAgICAgKiBlbHNlIGFzc3VtZWQgQ2lwaGVyUGFyYW1zIGFscmVhZHkgYW5kIHJldHVybnMgY2lwaGVydGV4dCB1bmNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLl9wYXJzZShjaXBoZXJ0ZXh0U3RyaW5nT3JQYXJhbXMsIGZvcm1hdCk7XG4gICAgICogQHBhcmFtIHs/fSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0LlxuICAgICAqIEBwYXJhbSB7P30gZm9ybWF0IFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIHVzZSB0byBwYXJzZSBzZXJpYWxpemVkIGNpcGhlcnRleHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgdW5zZXJpYWxpemVkIGNpcGhlcnRleHQuXG4gICAgICpcbiAgICAgKi9cbiAgICBTZXJpYWxpemFibGVDaXBoZXIuX3BhcnNlID0gLyoqXG4gICAgICogQ29udmVydHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0IHRvIENpcGhlclBhcmFtcyxcbiAgICAgKiBlbHNlIGFzc3VtZWQgQ2lwaGVyUGFyYW1zIGFscmVhZHkgYW5kIHJldHVybnMgY2lwaGVydGV4dCB1bmNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLl9wYXJzZShjaXBoZXJ0ZXh0U3RyaW5nT3JQYXJhbXMsIGZvcm1hdCk7XG4gICAgICogQHBhcmFtIHs/fSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0LlxuICAgICAqIEBwYXJhbSB7P30gZm9ybWF0IFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIHVzZSB0byBwYXJzZSBzZXJpYWxpemVkIGNpcGhlcnRleHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgdW5zZXJpYWxpemVkIGNpcGhlcnRleHQuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoY2lwaGVydGV4dCwgZm9ybWF0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2lwaGVydGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQucGFyc2UoY2lwaGVydGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2VyaWFsaXphYmxlQ2lwaGVyLmNmZyA9IHtcbiAgICAgICAgYmxvY2tTaXplOiA0LFxuICAgICAgICBpdjogbmV3IFdvcmRBcnJheShbXSksXG4gICAgICAgIGZvcm1hdDogT3BlblNTTFxuICAgIH07XG4gICAgcmV0dXJuIFNlcmlhbGl6YWJsZUNpcGhlcjtcbn0oKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciAgLyoqXG4gKiBAYWJzdHJhY3RcbiAqL1xuSGFzaGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIYXNoZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGFzaGVyKGNmZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBcbiAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgYmxvY2tTaXplOiA1MTIgLyAzMlxuICAgICAgICB9LCBjZmcpKSB8fCB0aGlzO1xuICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcbiAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG4gICAgICAgIF90aGlzLnJlc2V0KCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIGEgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBsZXQgU0hBMjU2ID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBMjU2KTtcbiAgICAgKiBAcGFyYW0gez99IGhhc2hlciBUaGUgaGFzaGVyIHRvIGNyZWF0ZSBhIGhlbHBlciBmb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgc2hvcnRjdXQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKi9cbiAgICBIYXNoZXIuX2NyZWF0ZUhlbHBlciA9IC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaG9ydGN1dCBmdW5jdGlvbiB0byBhIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbGV0IFNIQTI1NiA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTI1Nik7XG4gICAgICogQHBhcmFtIHs/fSBoYXNoZXIgVGhlIGhhc2hlciB0byBjcmVhdGUgYSBoZWxwZXIgZm9yLlxuICAgICAqXG4gICAgICogQHJldHVybiB7P30gVGhlIHNob3J0Y3V0IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gKGhhc2hlcikge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IGNmZ1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaGVscGVyKG1lc3NhZ2UsIGNmZykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGFzaGVyQ2xhc3MgPSBoYXNoZXI7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoYXNoZXJJbnN0YW5jZSA9IG5ldyBoYXNoZXJDbGFzcyhjZmcpO1xuICAgICAgICAgICAgcmV0dXJuIGhhc2hlckluc3RhbmNlLmZpbmFsaXplKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWxwZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoaXMgaGFzaGVyIHdpdGggYSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VVcGRhdGUgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kLlxuICAgICAqXG4gICAgICogQHJldHVybiBUaGlzIGhhc2hlci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgaGFzaGVyLnVwZGF0ZSgnbWVzc2FnZScpO1xuICAgICAqICAgICBoYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XG4gICAgICovXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGlzIGhhc2hlciB3aXRoIGEgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBoYXNoZXIudXBkYXRlKCdtZXNzYWdlJyk7XG4gICAgICogICAgIGhhc2hlci51cGRhdGUod29yZEFycmF5KTtcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VVcGRhdGUgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kLlxuICAgICAqXG4gICAgICogQHJldHVybiB7P30gVGhpcyBoYXNoZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICBIYXNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IC8qKlxuICAgICAqIFVwZGF0ZXMgdGhpcyBoYXNoZXIgd2l0aCBhIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgaGFzaGVyLnVwZGF0ZSgnbWVzc2FnZScpO1xuICAgICAqICAgICBoYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlVXBkYXRlIFRoZSBtZXNzYWdlIHRvIGFwcGVuZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99IFRoaXMgaGFzaGVyLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcbiAgICAgICAgLy8gQXBwZW5kXG4gICAgICAgIHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBoYXNoXG4gICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcbiAgICAgICAgLy8gQ2hhaW5hYmxlXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmluYWxpemVzIHRoZSBoYXNoIGNvbXB1dGF0aW9uLlxuICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbGV0IGhhc2ggPSBoYXNoZXIuZmluYWxpemUoKTtcbiAgICAgKiAgICAgbGV0IGhhc2ggPSBoYXNoZXIuZmluYWxpemUoJ21lc3NhZ2UnKTtcbiAgICAgKiAgICAgbGV0IGhhc2ggPSBoYXNoZXIuZmluYWxpemUod29yZEFycmF5KTtcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VVcGRhdGUgKE9wdGlvbmFsKSBBIGZpbmFsIG1lc3NhZ2UgdXBkYXRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7P30gVGhlIGhhc2guXG4gICAgICpcbiAgICAgKi9cbiAgICBIYXNoZXIucHJvdG90eXBlLmZpbmFsaXplID0gLyoqXG4gICAgICogRmluYWxpemVzIHRoZSBoYXNoIGNvbXB1dGF0aW9uLlxuICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbGV0IGhhc2ggPSBoYXNoZXIuZmluYWxpemUoKTtcbiAgICAgKiAgICAgbGV0IGhhc2ggPSBoYXNoZXIuZmluYWxpemUoJ21lc3NhZ2UnKTtcbiAgICAgKiAgICAgbGV0IGhhc2ggPSBoYXNoZXIuZmluYWxpemUod29yZEFycmF5KTtcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VVcGRhdGUgKE9wdGlvbmFsKSBBIGZpbmFsIG1lc3NhZ2UgdXBkYXRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7P30gVGhlIGhhc2guXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuICAgICAgICAvLyBGaW5hbCBtZXNzYWdlIHVwZGF0ZVxuICAgICAgICBpZiAobWVzc2FnZVVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhhc2ggPSB0aGlzLl9kb0ZpbmFsaXplKCk7XG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgIH07XG4gICAgcmV0dXJuIEhhc2hlcjtcbn0oQnVmZmVyZWRCbG9ja0FsZ29yaXRobSkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vLyBDb25zdGFudHMgdGFibGVcbnZhciAvKiogQHR5cGUgez99ICovIFQgPSBbXTtcbi8vIENvbXB1dGUgY29uc3RhbnRzXG5mb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgIFRbaV0gPSAoTWF0aC5hYnMoTWF0aC5zaW4oaSArIDEpKSAqIDB4MTAwMDAwMDAwKSB8IDA7XG59XG52YXIgTUQ1ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNRDUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTUQ1KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYVxuICAgICAqIEBwYXJhbSB7P30gYlxuICAgICAqIEBwYXJhbSB7P30gY1xuICAgICAqIEBwYXJhbSB7P30gZFxuICAgICAqIEBwYXJhbSB7P30geFxuICAgICAqIEBwYXJhbSB7P30gc1xuICAgICAqIEBwYXJhbSB7P30gdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTUQ1LkZGID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBhXG4gICAgICogQHBhcmFtIHs/fSBiXG4gICAgICogQHBhcmFtIHs/fSBjXG4gICAgICogQHBhcmFtIHs/fSBkXG4gICAgICogQHBhcmFtIHs/fSB4XG4gICAgICogQHBhcmFtIHs/fSBzXG4gICAgICogQHBhcmFtIHs/fSB0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuID0gYSArICgoYiAmIGMpIHwgKH5iICYgZCkpICsgeCArIHQ7XG4gICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFcbiAgICAgKiBAcGFyYW0gez99IGJcbiAgICAgKiBAcGFyYW0gez99IGNcbiAgICAgKiBAcGFyYW0gez99IGRcbiAgICAgKiBAcGFyYW0gez99IHhcbiAgICAgKiBAcGFyYW0gez99IHNcbiAgICAgKiBAcGFyYW0gez99IHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1ENS5HRyA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gYVxuICAgICAqIEBwYXJhbSB7P30gYlxuICAgICAqIEBwYXJhbSB7P30gY1xuICAgICAqIEBwYXJhbSB7P30gZFxuICAgICAqIEBwYXJhbSB7P30geFxuICAgICAqIEBwYXJhbSB7P30gc1xuICAgICAqIEBwYXJhbSB7P30gdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbiA9IGEgKyAoKGIgJiBkKSB8IChjICYgfmQpKSArIHggKyB0O1xuICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhXG4gICAgICogQHBhcmFtIHs/fSBiXG4gICAgICogQHBhcmFtIHs/fSBjXG4gICAgICogQHBhcmFtIHs/fSBkXG4gICAgICogQHBhcmFtIHs/fSB4XG4gICAgICogQHBhcmFtIHs/fSBzXG4gICAgICogQHBhcmFtIHs/fSB0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNRDUuSEggPSAvKipcbiAgICAgKiBAcGFyYW0gez99IGFcbiAgICAgKiBAcGFyYW0gez99IGJcbiAgICAgKiBAcGFyYW0gez99IGNcbiAgICAgKiBAcGFyYW0gez99IGRcbiAgICAgKiBAcGFyYW0gez99IHhcbiAgICAgKiBAcGFyYW0gez99IHNcbiAgICAgKiBAcGFyYW0gez99IHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG4gPSBhICsgKGIgXiBjIF4gZCkgKyB4ICsgdDtcbiAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYVxuICAgICAqIEBwYXJhbSB7P30gYlxuICAgICAqIEBwYXJhbSB7P30gY1xuICAgICAqIEBwYXJhbSB7P30gZFxuICAgICAqIEBwYXJhbSB7P30geFxuICAgICAqIEBwYXJhbSB7P30gc1xuICAgICAqIEBwYXJhbSB7P30gdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTUQ1LklJID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBhXG4gICAgICogQHBhcmFtIHs/fSBiXG4gICAgICogQHBhcmFtIHs/fSBjXG4gICAgICogQHBhcmFtIHs/fSBkXG4gICAgICogQHBhcmFtIHs/fSB4XG4gICAgICogQHBhcmFtIHs/fSBzXG4gICAgICogQHBhcmFtIHs/fSB0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuID0gYSArIChjIF4gKGIgfCB+ZCkpICsgeCArIHQ7XG4gICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1ENS5wcm90b3R5cGUucmVzZXQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gcmVzZXQgY29yZSB2YWx1ZXNcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5yZXNldC5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheShbXG4gICAgICAgICAgICAweDY3NDUyMzAxLCAweGVmY2RhYjg5LFxuICAgICAgICAgICAgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NlxuICAgICAgICBdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gTVxuICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNRDUucHJvdG90eXBlLl9kb1Byb2Nlc3NCbG9jayA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gTVxuICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG4gICAgICAgIC8vIFN3YXAgZW5kaWFuXG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBTaG9ydGN1dHNcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldF9pID0gb2Zmc2V0ICsgaTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIE1fb2Zmc2V0X2kgPSBNW29mZnNldF9pXTtcbiAgICAgICAgICAgIE1bb2Zmc2V0X2ldID0gKCgoKE1fb2Zmc2V0X2kgPDwgOCkgfCAoTV9vZmZzZXRfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcbiAgICAgICAgICAgICAgICAoKChNX29mZnNldF9pIDw8IDI0KSB8IChNX29mZnNldF9pID4+PiA4KSkgJiAweGZmMDBmZjAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBNX29mZnNldF8wID0gTVtvZmZzZXQgKyAwXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gTV9vZmZzZXRfMSA9IE1bb2Zmc2V0ICsgMV07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIE1fb2Zmc2V0XzIgPSBNW29mZnNldCArIDJdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBNX29mZnNldF8zID0gTVtvZmZzZXQgKyAzXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gTV9vZmZzZXRfNCA9IE1bb2Zmc2V0ICsgNF07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIE1fb2Zmc2V0XzUgPSBNW29mZnNldCArIDVdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBNX29mZnNldF82ID0gTVtvZmZzZXQgKyA2XTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gTV9vZmZzZXRfNyA9IE1bb2Zmc2V0ICsgN107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIE1fb2Zmc2V0XzggPSBNW29mZnNldCArIDhdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBNX29mZnNldF85ID0gTVtvZmZzZXQgKyA5XTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gTV9vZmZzZXRfMTAgPSBNW29mZnNldCArIDEwXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gTV9vZmZzZXRfMTEgPSBNW29mZnNldCArIDExXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gTV9vZmZzZXRfMTIgPSBNW29mZnNldCArIDEyXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gTV9vZmZzZXRfMTMgPSBNW29mZnNldCArIDEzXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gTV9vZmZzZXRfMTQgPSBNW29mZnNldCArIDE0XTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gTV9vZmZzZXRfMTUgPSBNW29mZnNldCArIDE1XTtcbiAgICAgICAgLy8gV29ya2luZyB2YXJpYWJsZXNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYSA9IEhbMF07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGIgPSBIWzFdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjID0gSFsyXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZCA9IEhbM107XG4gICAgICAgIC8vIENvbXB1dGF0aW9uXG4gICAgICAgIGEgPSBNRDUuRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfMCwgNywgVFswXSk7XG4gICAgICAgIGQgPSBNRDUuRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMSwgMTIsIFRbMV0pO1xuICAgICAgICBjID0gTUQ1LkZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzIsIDE3LCBUWzJdKTtcbiAgICAgICAgYiA9IE1ENS5GRihiLCBjLCBkLCBhLCBNX29mZnNldF8zLCAyMiwgVFszXSk7XG4gICAgICAgIGEgPSBNRDUuRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgNywgVFs0XSk7XG4gICAgICAgIGQgPSBNRDUuRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfNSwgMTIsIFRbNV0pO1xuICAgICAgICBjID0gTUQ1LkZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzYsIDE3LCBUWzZdKTtcbiAgICAgICAgYiA9IE1ENS5GRihiLCBjLCBkLCBhLCBNX29mZnNldF83LCAyMiwgVFs3XSk7XG4gICAgICAgIGEgPSBNRDUuRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfOCwgNywgVFs4XSk7XG4gICAgICAgIGQgPSBNRDUuRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfOSwgMTIsIFRbOV0pO1xuICAgICAgICBjID0gTUQ1LkZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzEwLCAxNywgVFsxMF0pO1xuICAgICAgICBiID0gTUQ1LkZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzExLCAyMiwgVFsxMV0pO1xuICAgICAgICBhID0gTUQ1LkZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA3LCBUWzEyXSk7XG4gICAgICAgIGQgPSBNRDUuRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTMsIDEyLCBUWzEzXSk7XG4gICAgICAgIGMgPSBNRDUuRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTQsIDE3LCBUWzE0XSk7XG4gICAgICAgIGIgPSBNRDUuRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTUsIDIyLCBUWzE1XSk7XG4gICAgICAgIGEgPSBNRDUuR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfMSwgNSwgVFsxNl0pO1xuICAgICAgICBkID0gTUQ1LkdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzYsIDksIFRbMTddKTtcbiAgICAgICAgYyA9IE1ENS5HRyhjLCBkLCBhLCBiLCBNX29mZnNldF8xMSwgMTQsIFRbMThdKTtcbiAgICAgICAgYiA9IE1ENS5HRyhiLCBjLCBkLCBhLCBNX29mZnNldF8wLCAyMCwgVFsxOV0pO1xuICAgICAgICBhID0gTUQ1LkdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzUsIDUsIFRbMjBdKTtcbiAgICAgICAgZCA9IE1ENS5HRyhkLCBhLCBiLCBjLCBNX29mZnNldF8xMCwgOSwgVFsyMV0pO1xuICAgICAgICBjID0gTUQ1LkdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE1LCAxNCwgVFsyMl0pO1xuICAgICAgICBiID0gTUQ1LkdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzQsIDIwLCBUWzIzXSk7XG4gICAgICAgIGEgPSBNRDUuR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgNSwgVFsyNF0pO1xuICAgICAgICBkID0gTUQ1LkdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE0LCA5LCBUWzI1XSk7XG4gICAgICAgIGMgPSBNRDUuR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMywgMTQsIFRbMjZdKTtcbiAgICAgICAgYiA9IE1ENS5HRyhiLCBjLCBkLCBhLCBNX29mZnNldF84LCAyMCwgVFsyN10pO1xuICAgICAgICBhID0gTUQ1LkdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEzLCA1LCBUWzI4XSk7XG4gICAgICAgIGQgPSBNRDUuR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMiwgOSwgVFsyOV0pO1xuICAgICAgICBjID0gTUQ1LkdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzcsIDE0LCBUWzMwXSk7XG4gICAgICAgIGIgPSBNRDUuR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfMTIsIDIwLCBUWzMxXSk7XG4gICAgICAgIGEgPSBNRDUuSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfNSwgNCwgVFszMl0pO1xuICAgICAgICBkID0gTUQ1LkhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzgsIDExLCBUWzMzXSk7XG4gICAgICAgIGMgPSBNRDUuSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTEsIDE2LCBUWzM0XSk7XG4gICAgICAgIGIgPSBNRDUuSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTQsIDIzLCBUWzM1XSk7XG4gICAgICAgIGEgPSBNRDUuSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfMSwgNCwgVFszNl0pO1xuICAgICAgICBkID0gTUQ1LkhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzQsIDExLCBUWzM3XSk7XG4gICAgICAgIGMgPSBNRDUuSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgMTYsIFRbMzhdKTtcbiAgICAgICAgYiA9IE1ENS5ISChiLCBjLCBkLCBhLCBNX29mZnNldF8xMCwgMjMsIFRbMzldKTtcbiAgICAgICAgYSA9IE1ENS5ISChhLCBiLCBjLCBkLCBNX29mZnNldF8xMywgNCwgVFs0MF0pO1xuICAgICAgICBkID0gTUQ1LkhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzAsIDExLCBUWzQxXSk7XG4gICAgICAgIGMgPSBNRDUuSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMywgMTYsIFRbNDJdKTtcbiAgICAgICAgYiA9IE1ENS5ISChiLCBjLCBkLCBhLCBNX29mZnNldF82LCAyMywgVFs0M10pO1xuICAgICAgICBhID0gTUQ1LkhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzksIDQsIFRbNDRdKTtcbiAgICAgICAgZCA9IE1ENS5ISChkLCBhLCBiLCBjLCBNX29mZnNldF8xMiwgMTEsIFRbNDVdKTtcbiAgICAgICAgYyA9IE1ENS5ISChjLCBkLCBhLCBiLCBNX29mZnNldF8xNSwgMTYsIFRbNDZdKTtcbiAgICAgICAgYiA9IE1ENS5ISChiLCBjLCBkLCBhLCBNX29mZnNldF8yLCAyMywgVFs0N10pO1xuICAgICAgICBhID0gTUQ1LklJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzAsIDYsIFRbNDhdKTtcbiAgICAgICAgZCA9IE1ENS5JSShkLCBhLCBiLCBjLCBNX29mZnNldF83LCAxMCwgVFs0OV0pO1xuICAgICAgICBjID0gTUQ1LklJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE0LCAxNSwgVFs1MF0pO1xuICAgICAgICBiID0gTUQ1LklJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzUsIDIxLCBUWzUxXSk7XG4gICAgICAgIGEgPSBNRDUuSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTIsIDYsIFRbNTJdKTtcbiAgICAgICAgZCA9IE1ENS5JSShkLCBhLCBiLCBjLCBNX29mZnNldF8zLCAxMCwgVFs1M10pO1xuICAgICAgICBjID0gTUQ1LklJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzEwLCAxNSwgVFs1NF0pO1xuICAgICAgICBiID0gTUQ1LklJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEsIDIxLCBUWzU1XSk7XG4gICAgICAgIGEgPSBNRDUuSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfOCwgNiwgVFs1Nl0pO1xuICAgICAgICBkID0gTUQ1LklJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE1LCAxMCwgVFs1N10pO1xuICAgICAgICBjID0gTUQ1LklJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzYsIDE1LCBUWzU4XSk7XG4gICAgICAgIGIgPSBNRDUuSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTMsIDIxLCBUWzU5XSk7XG4gICAgICAgIGEgPSBNRDUuSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgNiwgVFs2MF0pO1xuICAgICAgICBkID0gTUQ1LklJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzExLCAxMCwgVFs2MV0pO1xuICAgICAgICBjID0gTUQ1LklJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzIsIDE1LCBUWzYyXSk7XG4gICAgICAgIGIgPSBNRDUuSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfOSwgMjEsIFRbNjNdKTtcbiAgICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcbiAgICAgICAgSFswXSA9IChIWzBdICsgYSkgfCAwO1xuICAgICAgICBIWzFdID0gKEhbMV0gKyBiKSB8IDA7XG4gICAgICAgIEhbMl0gPSAoSFsyXSArIGMpIHwgMDtcbiAgICAgICAgSFszXSA9IChIWzNdICsgZCkgfCAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNRDUucHJvdG90eXBlLl9kb0ZpbmFsaXplID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGF0YVdvcmRzID0gZGF0YS53b3JkcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcbiAgICAgICAgLy8gQWRkIHBhZGRpbmdcbiAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5CaXRzVG90YWxIID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuQml0c1RvdGFsTCA9IG5CaXRzVG90YWw7XG4gICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTVdID0gKCgoKG5CaXRzVG90YWxIIDw8IDgpIHwgKG5CaXRzVG90YWxIID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuICAgICAgICAgICAgKCgobkJpdHNUb3RhbEggPDwgMjQpIHwgKG5CaXRzVG90YWxIID4+PiA4KSkgJiAweGZmMDBmZjAwKSk7XG4gICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gKCgoKG5CaXRzVG90YWxMIDw8IDgpIHwgKG5CaXRzVG90YWxMID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuICAgICAgICAgICAgKCgobkJpdHNUb3RhbEwgPDwgMjQpIHwgKG5CaXRzVG90YWxMID4+PiA4KSkgJiAweGZmMDBmZjAwKSk7XG4gICAgICAgIGRhdGEuc2lnQnl0ZXMgPSAoZGF0YVdvcmRzLmxlbmd0aCArIDEpICogNDtcbiAgICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3NcbiAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuICAgICAgICAvLyBTaG9ydGN1dHNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGFzaCA9IHRoaXMuX2hhc2g7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIEggPSBoYXNoLndvcmRzO1xuICAgICAgICAvLyBTd2FwIGVuZGlhblxuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBTaG9ydGN1dFxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gSF9pID0gSFtpXTtcbiAgICAgICAgICAgIEhbaV0gPSAoKChIX2kgPDwgOCkgfCAoSF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuICAgICAgICAgICAgICAgICgoKEhfaSA8PCAyNCkgfCAoSF9pID4+PiA4KSkgJiAweGZmMDBmZjAwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICB9O1xuICAgIHJldHVybiBNRDU7XG59KEhhc2hlcikpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgRXZwS0RGID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhlIGRlcml2YXRpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIGxldCBrZGYgPSBFdnBLREYuY3JlYXRlKCk7XG4gICAgICogICAgIGxldCBrZGYgPSBFdnBLREYuY3JlYXRlKHsga2V5U2l6ZTogOCB9KTtcbiAgICAgKiAgICAgbGV0IGtkZiA9IEV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiA4LCBpdGVyYXRpb25zOiAxMDAwIH0pO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEV2cEtERihjZmcpIHtcbiAgICAgICAgdGhpcy5jZmcgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGtleVNpemU6IDEyOCAvIDMyLFxuICAgICAgICAgICAgaGFzaGVyOiBNRDUsXG4gICAgICAgICAgICBpdGVyYXRpb25zOiAxXG4gICAgICAgIH0sIGNmZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cbiAgICAgKiBAcGFyYW0gc2FsdCBBIHNhbHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFRoZSBkZXJpdmVkIGtleS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbGV0IGtleSA9IGtkZi5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBEZXJpdmVzIGEga2V5IGZyb20gYSBwYXNzd29yZC5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBsZXQga2V5ID0ga2RmLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuICAgICAqIEBwYXJhbSB7P30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuICAgICAqIEBwYXJhbSB7P30gc2FsdCBBIHNhbHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgZGVyaXZlZCBrZXkuXG4gICAgICpcbiAgICAgKi9cbiAgICBFdnBLREYucHJvdG90eXBlLmNvbXB1dGUgPSAvKipcbiAgICAgKiBEZXJpdmVzIGEga2V5IGZyb20gYSBwYXNzd29yZC5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBsZXQga2V5ID0ga2RmLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuICAgICAqIEBwYXJhbSB7P30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuICAgICAqIEBwYXJhbSB7P30gc2FsdCBBIHNhbHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgZGVyaXZlZCBrZXkuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQpIHtcbiAgICAgICAgLy8gSW5pdCBoYXNoZXJcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGFzaGVyID0gbmV3ICgvKiogQHR5cGUgez99ICovICh0aGlzLmNmZy5oYXNoZXIpKSgpO1xuICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXJpdmVkS2V5ID0gbmV3IFdvcmRBcnJheSgpO1xuICAgICAgICAvLyBHZW5lcmF0ZSBrZXlcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmxvY2s7XG4gICAgICAgIHdoaWxlIChkZXJpdmVkS2V5LndvcmRzLmxlbmd0aCA8IHRoaXMuY2ZnLmtleVNpemUpIHtcbiAgICAgICAgICAgIGlmIChibG9jaykge1xuICAgICAgICAgICAgICAgIGhhc2hlci51cGRhdGUoYmxvY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvY2sgPSBoYXNoZXIudXBkYXRlKHBhc3N3b3JkKS5maW5hbGl6ZShzYWx0KTtcbiAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuICAgICAgICAgICAgLy8gSXRlcmF0aW9uc1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMTsgaSA8IHRoaXMuY2ZnLml0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgICAgIGJsb2NrID0gaGFzaGVyLmZpbmFsaXplKGJsb2NrKTtcbiAgICAgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlcml2ZWRLZXkuY29uY2F0KGJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBkZXJpdmVkS2V5LnNpZ0J5dGVzID0gdGhpcy5jZmcua2V5U2l6ZSAqIDQ7XG4gICAgICAgIHJldHVybiBkZXJpdmVkS2V5O1xuICAgIH07XG4gICAgcmV0dXJuIEV2cEtERjtcbn0oKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbnZhciBPcGVuU1NMS2RmID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9wZW5TU0xLZGYoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcml2ZXMgYSBrZXkgYW5kIElWIGZyb20gYSBwYXNzd29yZC5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBsZXQgZGVyaXZlZFBhcmFtcyA9IE9wZW5TU0wuZXhlY3V0ZSgnUGFzc3dvcmQnLCAyNTYvMzIsIDEyOC8zMik7XG4gICAgICogICAgIGxldCBkZXJpdmVkUGFyYW1zID0gT3BlblNTTC5leGVjdXRlKCdQYXNzd29yZCcsIDI1Ni8zMiwgMTI4LzMyLCAnc2FsdHNhbHQnKTtcbiAgICAgKiBAcGFyYW0gez99IHBhc3N3b3JkIFRoZSBwYXNzd29yZCB0byBkZXJpdmUgZnJvbS5cbiAgICAgKiBAcGFyYW0gez99IGtleVNpemUgVGhlIHNpemUgaW4gd29yZHMgb2YgdGhlIGtleSB0byBnZW5lcmF0ZS5cbiAgICAgKiBAcGFyYW0gez99IGl2U2l6ZSBUaGUgc2l6ZSBpbiB3b3JkcyBvZiB0aGUgSVYgdG8gZ2VuZXJhdGUuXG4gICAgICogQHBhcmFtIHs/PX0gc2FsdCAoT3B0aW9uYWwpIEEgNjQtYml0IHNhbHQgdG8gdXNlLiBJZiBvbWl0dGVkLCBhIHNhbHQgd2lsbCBiZSBnZW5lcmF0ZWQgcmFuZG9tbHkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0IHdpdGggdGhlIGtleSwgSVYsIGFuZCBzYWx0LlxuICAgICAqXG4gICAgICovXG4gICAgT3BlblNTTEtkZi5leGVjdXRlID0gLyoqXG4gICAgICogRGVyaXZlcyBhIGtleSBhbmQgSVYgZnJvbSBhIHBhc3N3b3JkLlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIGxldCBkZXJpdmVkUGFyYW1zID0gT3BlblNTTC5leGVjdXRlKCdQYXNzd29yZCcsIDI1Ni8zMiwgMTI4LzMyKTtcbiAgICAgKiAgICAgbGV0IGRlcml2ZWRQYXJhbXMgPSBPcGVuU1NMLmV4ZWN1dGUoJ1Bhc3N3b3JkJywgMjU2LzMyLCAxMjgvMzIsICdzYWx0c2FsdCcpO1xuICAgICAqIEBwYXJhbSB7P30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkIHRvIGRlcml2ZSBmcm9tLlxuICAgICAqIEBwYXJhbSB7P30ga2V5U2l6ZSBUaGUgc2l6ZSBpbiB3b3JkcyBvZiB0aGUga2V5IHRvIGdlbmVyYXRlLlxuICAgICAqIEBwYXJhbSB7P30gaXZTaXplIFRoZSBzaXplIGluIHdvcmRzIG9mIHRoZSBJViB0byBnZW5lcmF0ZS5cbiAgICAgKiBAcGFyYW0gez89fSBzYWx0IChPcHRpb25hbCkgQSA2NC1iaXQgc2FsdCB0byB1c2UuIElmIG9taXR0ZWQsIGEgc2FsdCB3aWxsIGJlIGdlbmVyYXRlZCByYW5kb21seS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99IEEgY2lwaGVyIHBhcmFtcyBvYmplY3Qgd2l0aCB0aGUga2V5LCBJViwgYW5kIHNhbHQuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiAocGFzc3dvcmQsIGtleVNpemUsIGl2U2l6ZSwgc2FsdCkge1xuICAgICAgICAvLyBHZW5lcmF0ZSByYW5kb20gc2FsdFxuICAgICAgICBpZiAoIXNhbHQpIHtcbiAgICAgICAgICAgIHNhbHQgPSBXb3JkQXJyYXkucmFuZG9tKDY0IC8gOCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgSVZcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5ID0gKG5ldyBFdnBLREYoeyBrZXlTaXplOiBrZXlTaXplICsgaXZTaXplIH0pKS5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcbiAgICAgICAgLy8gU2VwYXJhdGUga2V5IGFuZCBJVlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpdiA9IG5ldyBXb3JkQXJyYXkoa2V5LndvcmRzLnNsaWNlKGtleVNpemUpLCBpdlNpemUgKiA0KTtcbiAgICAgICAga2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7XG4gICAgICAgIC8vIFJldHVybiBwYXJhbXNcbiAgICAgICAgcmV0dXJuIG5ldyBDaXBoZXJQYXJhbXMoeyBrZXk6IGtleSwgaXY6IGl2LCBzYWx0OiBzYWx0IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE9wZW5TU0xLZGY7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgUGFzc3dvcmRCYXNlZENpcGhlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXNzd29yZEJhc2VkQ2lwaGVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNyeXB0cyBhIG1lc3NhZ2UgdXNpbmcgYSBwYXNzd29yZC5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmVuY3J5cHQoQUVTLCBtZXNzYWdlLCAncGFzc3dvcmQnKTtcbiAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5lbmNyeXB0KEFFUywgbWVzc2FnZSwgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IE9wZW5TU0wgfSk7XG4gICAgICogQHBhcmFtIHs/fSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBlbmNyeXB0LlxuICAgICAqIEBwYXJhbSB7P30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuICAgICAqIEBwYXJhbSB7Pz19IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99IEEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG4gICAgICpcbiAgICAgKi9cbiAgICBQYXNzd29yZEJhc2VkQ2lwaGVyLmVuY3J5cHQgPSAvKipcbiAgICAgKiBFbmNyeXB0cyBhIG1lc3NhZ2UgdXNpbmcgYSBwYXNzd29yZC5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmVuY3J5cHQoQUVTLCBtZXNzYWdlLCAncGFzc3dvcmQnKTtcbiAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5lbmNyeXB0KEFFUywgbWVzc2FnZSwgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IE9wZW5TU0wgfSk7XG4gICAgICogQHBhcmFtIHs/fSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBlbmNyeXB0LlxuICAgICAqIEBwYXJhbSB7P30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuICAgICAqIEBwYXJhbSB7Pz19IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99IEEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoY2lwaGVyLCBtZXNzYWdlLCBwYXNzd29yZCwgY2ZnKSB7XG4gICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNmZywgY2ZnKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhIGtkZlxuICAgICAgICBpZiAoY29uZmlnLmtkZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmcga2RmIGluIGNvbmZpZycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlcml2ZSBrZXkgYW5kIG90aGVyIHBhcmFtc1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXJpdmVkUGFyYW1zID0gY29uZmlnLmtkZi5leGVjdXRlKHBhc3N3b3JkLCBjaXBoZXIua2V5U2l6ZSwgY2lwaGVyLml2U2l6ZSk7XG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgYW4gSVZcbiAgICAgICAgaWYgKGRlcml2ZWRQYXJhbXMuaXYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gQWRkIElWIHRvIGNvbmZpZ1xuICAgICAgICAgICAgY29uZmlnLml2ID0gZGVyaXZlZFBhcmFtcy5pdjtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbmNyeXB0XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNpcGhlcnRleHQgPSBTZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdC5jYWxsKHRoaXMsIGNpcGhlciwgbWVzc2FnZSwgZGVyaXZlZFBhcmFtcy5rZXksIGNvbmZpZyk7XG4gICAgICAgIC8vIE1peCBpbiBkZXJpdmVkIHBhcmFtc1xuICAgICAgICByZXR1cm4gY2lwaGVydGV4dC5leHRlbmQoZGVyaXZlZFBhcmFtcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWNyeXB0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQgdXNpbmcgYSBwYXNzd29yZC5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gUGFzc3dvcmRCYXNlZENpcGhlci5kZWNyeXB0KEFFUywgZm9ybWF0dGVkQ2lwaGVydGV4dCwgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IE9wZW5TU0wgfSk7XG4gICAgICogICAgIHZhciBwbGFpbnRleHQgPSBQYXNzd29yZEJhc2VkQ2lwaGVyLmRlY3J5cHQoQUVTLCBjaXBoZXJ0ZXh0UGFyYW1zLCAncGFzc3dvcmQnLCB7IGZvcm1hdDogT3BlblNTTCB9KTtcbiAgICAgKiBAcGFyYW0gez99IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG4gICAgICogQHBhcmFtIHs/fSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0IHRvIGRlY3J5cHQuXG4gICAgICogQHBhcmFtIHs/fSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG4gICAgICogQHBhcmFtIHs/PX0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7P30gVGhlIHBsYWludGV4dC5cbiAgICAgKlxuICAgICAqL1xuICAgIFBhc3N3b3JkQmFzZWRDaXBoZXIuZGVjcnlwdCA9IC8qKlxuICAgICAqIERlY3J5cHRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dCB1c2luZyBhIHBhc3N3b3JkLlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHZhciBwbGFpbnRleHQgPSBQYXNzd29yZEJhc2VkQ2lwaGVyLmRlY3J5cHQoQUVTLCBmb3JtYXR0ZWRDaXBoZXJ0ZXh0LCAncGFzc3dvcmQnLCB7IGZvcm1hdDogT3BlblNTTCB9KTtcbiAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IFBhc3N3b3JkQmFzZWRDaXBoZXIuZGVjcnlwdChBRVMsIGNpcGhlcnRleHRQYXJhbXMsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBPcGVuU1NMIH0pO1xuICAgICAqIEBwYXJhbSB7P30gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gez99IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQgdG8gZGVjcnlwdC5cbiAgICAgKiBAcGFyYW0gez99IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cbiAgICAgKiBAcGFyYW0gez89fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgcGxhaW50ZXh0LlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gKGNpcGhlciwgY2lwaGVydGV4dCwgcGFzc3dvcmQsIGNmZykge1xuICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jZmcsIGNmZyk7XG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgYSBrZGZcbiAgICAgICAgaWYgKGNvbmZpZy5mb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGZvcm1hdCBpbiBjb25maWcnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBDaXBoZXJQYXJhbXNcbiAgICAgICAgY2lwaGVydGV4dCA9IHRoaXMuX3BhcnNlKGNpcGhlcnRleHQsIGNvbmZpZy5mb3JtYXQpO1xuICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGEga2RmXG4gICAgICAgIGlmIChjb25maWcua2RmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGhlIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIG11c3QgYmUgc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgb3RoZXIgcGFyYW1zXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcml2ZWRQYXJhbXMgPSBjb25maWcua2RmLmV4ZWN1dGUocGFzc3dvcmQsIGNpcGhlci5rZXlTaXplLCBjaXBoZXIuaXZTaXplLCBjaXBoZXJ0ZXh0LnNhbHQpO1xuICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGFuIElWXG4gICAgICAgIGlmIChkZXJpdmVkUGFyYW1zLml2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIEFkZCBJViB0byBjb25maWdcbiAgICAgICAgICAgIGNvbmZpZy5pdiA9IGRlcml2ZWRQYXJhbXMuaXY7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVjcnlwdFxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGFpbnRleHQgPSBTZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdC5jYWxsKHRoaXMsIGNpcGhlciwgY2lwaGVydGV4dCwgZGVyaXZlZFBhcmFtcy5rZXksIGNvbmZpZyk7XG4gICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQgdG8gQ2lwaGVyUGFyYW1zLFxuICAgICAqIGVsc2UgYXNzdW1lZCBDaXBoZXJQYXJhbXMgYWxyZWFkeSBhbmQgcmV0dXJucyBjaXBoZXJ0ZXh0IHVuY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuX3BhcnNlKGNpcGhlcnRleHRTdHJpbmdPclBhcmFtcywgZm9ybWF0KTtcbiAgICAgKiBAcGFyYW0gez99IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQuXG4gICAgICogQHBhcmFtIHs/fSBmb3JtYXQgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gdXNlIHRvIHBhcnNlIHNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99IFRoZSB1bnNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cbiAgICAgKlxuICAgICAqL1xuICAgIFBhc3N3b3JkQmFzZWRDaXBoZXIuX3BhcnNlID0gLyoqXG4gICAgICogQ29udmVydHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0IHRvIENpcGhlclBhcmFtcyxcbiAgICAgKiBlbHNlIGFzc3VtZWQgQ2lwaGVyUGFyYW1zIGFscmVhZHkgYW5kIHJldHVybnMgY2lwaGVydGV4dCB1bmNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLl9wYXJzZShjaXBoZXJ0ZXh0U3RyaW5nT3JQYXJhbXMsIGZvcm1hdCk7XG4gICAgICogQHBhcmFtIHs/fSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0LlxuICAgICAqIEBwYXJhbSB7P30gZm9ybWF0IFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIHVzZSB0byBwYXJzZSBzZXJpYWxpemVkIGNpcGhlcnRleHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgdW5zZXJpYWxpemVkIGNpcGhlcnRleHQuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoY2lwaGVydGV4dCwgZm9ybWF0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2lwaGVydGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQucGFyc2UoY2lwaGVydGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFzc3dvcmRCYXNlZENpcGhlci5jZmcgPSB7XG4gICAgICAgIGJsb2NrU2l6ZTogNCxcbiAgICAgICAgaXY6IG5ldyBXb3JkQXJyYXkoW10pLFxuICAgICAgICBmb3JtYXQ6IE9wZW5TU0wsXG4gICAgICAgIGtkZjogT3BlblNTTEtkZlxuICAgIH07XG4gICAgcmV0dXJuIFBhc3N3b3JkQmFzZWRDaXBoZXI7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgQ2lwaGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDaXBoZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2lwaGVyKHhmb3JtTW9kZSwga2V5LCBjZmcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gXG4gICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGJsb2NrU2l6ZTogMVxuICAgICAgICB9LCBjZmcpKSB8fCB0aGlzO1xuICAgICAgICAvLyBTdG9yZSB0cmFuc2Zvcm0gbW9kZSBhbmQga2V5XG4gICAgICAgIC8vIFN0b3JlIHRyYW5zZm9ybSBtb2RlIGFuZCBrZXlcbiAgICAgICAgX3RoaXMuX3hmb3JtTW9kZSA9IHhmb3JtTW9kZTtcbiAgICAgICAgX3RoaXMuX2tleSA9IGtleTtcbiAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG4gICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xuICAgICAgICBfdGhpcy5yZXNldCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhpcyBjaXBoZXIgaW4gZW5jcnlwdGlvbiBtb2RlLlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIGxldCBjaXBoZXIgPSBBRVMuY3JlYXRlRW5jcnlwdG9yKGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG4gICAgICogQHBhcmFtIHs/fSBrZXkgVGhlIGtleS5cbiAgICAgKiBAcGFyYW0gez89fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fSBBIGNpcGhlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqL1xuICAgIENpcGhlci5jcmVhdGVFbmNyeXB0b3IgPSAvKipcbiAgICAgKiBDcmVhdGVzIHRoaXMgY2lwaGVyIGluIGVuY3J5cHRpb24gbW9kZS5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBsZXQgY2lwaGVyID0gQUVTLmNyZWF0ZUVuY3J5cHRvcihrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xuICAgICAqIEBwYXJhbSB7P30ga2V5IFRoZSBrZXkuXG4gICAgICogQHBhcmFtIHs/PX0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7P30gQSBjaXBoZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoa2V5LCBjZmcpIHtcbiAgICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgdHlwZXNjcmlwdCBub3QgYmVpbmcgYWJsZSB0byBjcmVhdGUgYSBhYnN0cmFjdCBjcmVhdG9yIGZ1bmN0aW9uIGRpcmVjdGx5XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRoaXNDbGFzcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgdGhpc0NsYXNzKHRoaXMuX0VOQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoaXMgY2lwaGVyIGluIGRlY3J5cHRpb24gbW9kZS5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBsZXQgY2lwaGVyID0gQUVTLmNyZWF0ZURlY3J5cHRvcihrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xuICAgICAqIEBwYXJhbSB7P30ga2V5IFRoZSBrZXkuXG4gICAgICogQHBhcmFtIHs/PX0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7P30gQSBjaXBoZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBDaXBoZXIuY3JlYXRlRGVjcnlwdG9yID0gLyoqXG4gICAgICogQ3JlYXRlcyB0aGlzIGNpcGhlciBpbiBkZWNyeXB0aW9uIG1vZGUuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbGV0IGNpcGhlciA9IEFFUy5jcmVhdGVEZWNyeXB0b3Ioa2V5V29yZEFycmF5LCB7IGl2OiBpdldvcmRBcnJheSB9KTtcbiAgICAgKiBAcGFyYW0gez99IGtleSBUaGUga2V5LlxuICAgICAqIEBwYXJhbSB7Pz19IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99IEEgY2lwaGVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gKGtleSwgY2ZnKSB7XG4gICAgICAgIC8vIHdvcmthcm91bmQgZm9yIHR5cGVzY3JpcHQgbm90IGJlaW5nIGFibGUgdG8gY3JlYXRlIGEgYWJzdHJhY3QgY3JlYXRvciBmdW5jdGlvbiBkaXJlY3RseVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0aGlzQ2xhc3MgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXNDbGFzcyh0aGlzLl9ERUNfWEZPUk1fTU9ERSwga2V5LCBjZmcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBzaG9ydGN1dCBmdW5jdGlvbnMgdG8gYSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIGxldCBBRVMgPSBDaXBoZXIuX2NyZWF0ZUhlbHBlcihBRVNBbGdvcml0aG0pO1xuICAgICAqIEBwYXJhbSB7P30gY2lwaGVyIFRoZSBjaXBoZXIgdG8gY3JlYXRlIGEgaGVscGVyIGZvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99IEFuIG9iamVjdCB3aXRoIGVuY3J5cHQgYW5kIGRlY3J5cHQgc2hvcnRjdXQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICovXG4gICAgQ2lwaGVyLl9jcmVhdGVIZWxwZXIgPSAvKipcbiAgICAgKiBDcmVhdGVzIHNob3J0Y3V0IGZ1bmN0aW9ucyB0byBhIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbGV0IEFFUyA9IENpcGhlci5fY3JlYXRlSGVscGVyKEFFU0FsZ29yaXRobSk7XG4gICAgICogQHBhcmFtIHs/fSBjaXBoZXIgVGhlIGNpcGhlciB0byBjcmVhdGUgYSBoZWxwZXIgZm9yLlxuICAgICAqXG4gICAgICogQHJldHVybiB7P30gQW4gb2JqZWN0IHdpdGggZW5jcnlwdCBhbmQgZGVjcnlwdCBzaG9ydGN1dCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoY2lwaGVyKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgICAgICogQHBhcmFtIHs/fSBrZXlcbiAgICAgICAgICogQHBhcmFtIHs/PX0gY2ZnXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBlbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFzc3dvcmRCYXNlZENpcGhlci5lbmNyeXB0KGNpcGhlciwgbWVzc2FnZSwga2V5LCBjZmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KGNpcGhlciwgbWVzc2FnZSwga2V5LCBjZmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNpcGhlcnRleHRcbiAgICAgICAgICogQHBhcmFtIHs/fSBrZXlcbiAgICAgICAgICogQHBhcmFtIHs/PX0gY2ZnXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBkZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFzc3dvcmRCYXNlZENpcGhlci5kZWNyeXB0KGNpcGhlciwgY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KGNpcGhlciwgY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbmNyeXB0OiBlbmNyeXB0LFxuICAgICAgICAgICAgZGVjcnlwdDogZGVjcnlwdFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBkYXRhIHRvIGJlIGVuY3J5cHRlZCBvciBkZWNyeXB0ZWQuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbGV0IGVuY3J5cHRlZCA9IGNpcGhlci5wcm9jZXNzKCdkYXRhJyk7XG4gICAgICogICAgIGxldCBlbmNyeXB0ZWQgPSBjaXBoZXIucHJvY2Vzcyh3b3JkQXJyYXkpO1xuICAgICAqIEBwYXJhbSB7P30gZGF0YVVwZGF0ZSBUaGUgZGF0YSB0byBlbmNyeXB0IG9yIGRlY3J5cHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgZGF0YSBhZnRlciBwcm9jZXNzaW5nLlxuICAgICAqXG4gICAgICovXG4gICAgQ2lwaGVyLnByb3RvdHlwZS5wcm9jZXNzID0gLyoqXG4gICAgICogQWRkcyBkYXRhIHRvIGJlIGVuY3J5cHRlZCBvciBkZWNyeXB0ZWQuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbGV0IGVuY3J5cHRlZCA9IGNpcGhlci5wcm9jZXNzKCdkYXRhJyk7XG4gICAgICogICAgIGxldCBlbmNyeXB0ZWQgPSBjaXBoZXIucHJvY2Vzcyh3b3JkQXJyYXkpO1xuICAgICAqIEBwYXJhbSB7P30gZGF0YVVwZGF0ZSBUaGUgZGF0YSB0byBlbmNyeXB0IG9yIGRlY3J5cHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgZGF0YSBhZnRlciBwcm9jZXNzaW5nLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gKGRhdGFVcGRhdGUpIHtcbiAgICAgICAgLy8gQXBwZW5kXG4gICAgICAgIHRoaXMuX2FwcGVuZChkYXRhVXBkYXRlKTtcbiAgICAgICAgLy8gUHJvY2VzcyBhdmFpbGFibGUgYmxvY2tzXG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaW5hbGl6ZXMgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiBwcm9jZXNzLlxuICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSgpO1xuICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKCdkYXRhJyk7XG4gICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUod29yZEFycmF5KTtcbiAgICAgKiBAcGFyYW0gez89fSBkYXRhVXBkYXRlIFRoZSBmaW5hbCBkYXRhIHRvIGVuY3J5cHQgb3IgZGVjcnlwdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99IFRoZSBkYXRhIGFmdGVyIGZpbmFsIHByb2Nlc3NpbmcuXG4gICAgICpcbiAgICAgKi9cbiAgICBDaXBoZXIucHJvdG90eXBlLmZpbmFsaXplID0gLyoqXG4gICAgICogRmluYWxpemVzIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gcHJvY2Vzcy5cbiAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUoKTtcbiAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSgnZGF0YScpO1xuICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG4gICAgICogQHBhcmFtIHs/PX0gZGF0YVVwZGF0ZSBUaGUgZmluYWwgZGF0YSB0byBlbmNyeXB0IG9yIGRlY3J5cHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fSBUaGUgZGF0YSBhZnRlciBmaW5hbCBwcm9jZXNzaW5nLlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gKGRhdGFVcGRhdGUpIHtcbiAgICAgICAgLy8gRmluYWwgZGF0YSB1cGRhdGVcbiAgICAgICAgaWYgKGRhdGFVcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2FwcGVuZChkYXRhVXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWNpcGhlciBsb2dpY1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaW5hbFByb2Nlc3NlZERhdGEgPSB0aGlzLl9kb0ZpbmFsaXplKCk7XG4gICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZERhdGE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBlbmNyeXB0aW9uIG1vZGUuXG4gICAgICovXG4gICAgQ2lwaGVyLl9FTkNfWEZPUk1fTU9ERSA9IDE7XG4gICAgLyoqXG4gICAgICogQSBjb25zdGFudCByZXByZXNlbnRpbmcgZGVjcnlwdGlvbiBtb2RlLlxuICAgICAqL1xuICAgIENpcGhlci5fREVDX1hGT1JNX01PREUgPSAyO1xuICAgIC8qKlxuICAgICAqIFRoaXMgY2lwaGVyJ3Mga2V5IHNpemUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzIC8gMzIgQml0cylcbiAgICAgKi9cbiAgICBDaXBoZXIua2V5U2l6ZSA9IDQ7XG4gICAgLyoqXG4gICAgICogVGhpcyBjaXBoZXIncyBJViBzaXplLiBEZWZhdWx0OiA0ICgxMjggYml0cyAvIDMyIEJpdHMpXG4gICAgICovXG4gICAgQ2lwaGVyLml2U2l6ZSA9IDQ7XG4gICAgcmV0dXJuIENpcGhlcjtcbn0oQnVmZmVyZWRCbG9ja0FsZ29yaXRobSkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgLyoqXG4gKiBAYWJzdHJhY3RcbiAqL1xuQmxvY2tDaXBoZXJNb2RlQWxnb3JpdGhtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJsb2NrQ2lwaGVyTW9kZUFsZ29yaXRobShjaXBoZXIsIGl2KSB7XG4gICAgICAgIHRoaXMuaW5pdChjaXBoZXIsIGl2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIG1vZGUuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgdmFyIG1vZGUgPSBDQkMuRW5jcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2LndvcmRzKTtcbiAgICAgKiBAcGFyYW0gez99IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gez89fSBpdiBUaGUgSVYgd29yZHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJsb2NrQ2lwaGVyTW9kZUFsZ29yaXRobS5wcm90b3R5cGUuaW5pdCA9IC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBtb2RlLlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHZhciBtb2RlID0gQ0JDLkVuY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdi53b3Jkcyk7XG4gICAgICogQHBhcmFtIHs/fSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHs/PX0gaXYgVGhlIElWIHdvcmRzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xuICAgICAgICB0aGlzLl9jaXBoZXIgPSBjaXBoZXI7XG4gICAgICAgIHRoaXMuX2l2ID0gaXY7XG4gICAgfTtcbiAgICByZXR1cm4gQmxvY2tDaXBoZXJNb2RlQWxnb3JpdGhtO1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIEJsb2NrQ2lwaGVyTW9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCbG9ja0NpcGhlck1vZGUoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhpcyBtb2RlIGZvciBlbmNyeXB0aW9uLlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHZhciBtb2RlID0gQ0JDLmNyZWF0ZUVuY3J5cHRvcihjaXBoZXIsIGl2LndvcmRzKTtcbiAgICAgKiBAcGFyYW0gez99IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gez99IGl2IFRoZSBJViB3b3Jkcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmxvY2tDaXBoZXJNb2RlLmNyZWF0ZUVuY3J5cHRvciA9IC8qKlxuICAgICAqIENyZWF0ZXMgdGhpcyBtb2RlIGZvciBlbmNyeXB0aW9uLlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIHZhciBtb2RlID0gQ0JDLmNyZWF0ZUVuY3J5cHRvcihjaXBoZXIsIGl2LndvcmRzKTtcbiAgICAgKiBAcGFyYW0gez99IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gez99IGl2IFRoZSBJViB3b3Jkcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGNpcGhlciwgaXYpIHtcbiAgICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgdHlwZXNjcmlwdCBub3QgYmVpbmcgYWJsZSB0byBjcmVhdGUgYSBhYnN0cmFjdCBjcmVhdG9yIGZ1bmN0aW9uIGRpcmVjdGx5XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuY3J5cHRvckNsYXNzID0gdGhpcy5FbmNyeXB0b3I7XG4gICAgICAgIHJldHVybiBuZXcgZW5jcnlwdG9yQ2xhc3MoY2lwaGVyLCBpdik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoaXMgbW9kZSBmb3IgZGVjcnlwdGlvbi5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgbW9kZSA9IENCQy5jcmVhdGVEZWNyeXB0b3IoY2lwaGVyLCBpdi53b3Jkcyk7XG4gICAgICogQHBhcmFtIHs/fSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHs/fSBpdiBUaGUgSVYgd29yZHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJsb2NrQ2lwaGVyTW9kZS5jcmVhdGVEZWNyeXB0b3IgPSAvKipcbiAgICAgKiBDcmVhdGVzIHRoaXMgbW9kZSBmb3IgZGVjcnlwdGlvbi5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICB2YXIgbW9kZSA9IENCQy5jcmVhdGVEZWNyeXB0b3IoY2lwaGVyLCBpdi53b3Jkcyk7XG4gICAgICogQHBhcmFtIHs/fSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHs/fSBpdiBUaGUgSVYgd29yZHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XG4gICAgICAgIC8vIHdvcmthcm91bmQgZm9yIHR5cGVzY3JpcHQgbm90IGJlaW5nIGFibGUgdG8gY3JlYXRlIGEgYWJzdHJhY3QgY3JlYXRvciBmdW5jdGlvbiBkaXJlY3RseVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWNyeXB0b3JDbGFzcyA9IHRoaXMuRGVjcnlwdG9yO1xuICAgICAgICByZXR1cm4gbmV3IGRlY3J5cHRvckNsYXNzKGNpcGhlciwgaXYpO1xuICAgIH07XG4gICAgQmxvY2tDaXBoZXJNb2RlLkVuY3J5cHRvciA9IEJsb2NrQ2lwaGVyTW9kZUFsZ29yaXRobTtcbiAgICBCbG9ja0NpcGhlck1vZGUuRGVjcnlwdG9yID0gQmxvY2tDaXBoZXJNb2RlQWxnb3JpdGhtO1xuICAgIHJldHVybiBCbG9ja0NpcGhlck1vZGU7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgQ0JDRW5jcnlwdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDQkNFbmNyeXB0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ0JDRW5jcnlwdG9yKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcbiAgICAgKiBAcGFyYW0gez99IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXG4gICAgICogQHBhcmFtIHs/fSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDQkNFbmNyeXB0b3IucHJvdG90eXBlLnByb2Nlc3NCbG9jayA9IC8qKlxuICAgICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcbiAgICAgKiBAcGFyYW0gez99IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXG4gICAgICogQHBhcmFtIHs/fSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGEgYmxvY2tTaXplXG4gICAgICAgIGlmICh0aGlzLl9jaXBoZXIuY2ZnLmJsb2NrU2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgYmxvY2tTaXplIGluIGNpcGhlciBjb25maWcnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBYT1IgYW5kIGVuY3J5cHRcbiAgICAgICAgdGhpcy54b3JCbG9jayh3b3Jkcywgb2Zmc2V0LCB0aGlzLl9jaXBoZXIuY2ZnLmJsb2NrU2l6ZSk7XG4gICAgICAgIHRoaXMuX2NpcGhlci5lbmNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG4gICAgICAgIC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xuICAgICAgICB0aGlzLl9wcmV2QmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIHRoaXMuX2NpcGhlci5jZmcuYmxvY2tTaXplKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gd29yZHNcbiAgICAgKiBAcGFyYW0gez99IG9mZnNldFxuICAgICAqIEBwYXJhbSB7P30gYmxvY2tTaXplXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDQkNFbmNyeXB0b3IucHJvdG90eXBlLnhvckJsb2NrID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSB3b3Jkc1xuICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0XG4gICAgICogQHBhcmFtIHs/fSBibG9ja1NpemVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpIHtcbiAgICAgICAgLy8gQ2hvb3NlIG1peGluZyBibG9ja1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBibG9jaztcbiAgICAgICAgaWYgKHRoaXMuX2l2KSB7XG4gICAgICAgICAgICBibG9jayA9IHRoaXMuX2l2O1xuICAgICAgICAgICAgLy8gUmVtb3ZlIElWIGZvciBzdWJzZXF1ZW50IGJsb2Nrc1xuICAgICAgICAgICAgdGhpcy5faXYgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBibG9jayA9IHRoaXMuX3ByZXZCbG9jaztcbiAgICAgICAgfVxuICAgICAgICAvLyBibG9jayBzaG91bGQgbmV2ZXIgYmUgdW5kZWZpbmVkIGJ1dCB3ZSB3YW50IHRvIG1ha2UgdHlwZXNjcmlwdCBoYXBweVxuICAgICAgICBpZiAoYmxvY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gWE9SIGJsb2Nrc1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGJsb2NrU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgd29yZHNbb2Zmc2V0ICsgaV0gXj0gYmxvY2tbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDQkNFbmNyeXB0b3I7XG59KEJsb2NrQ2lwaGVyTW9kZUFsZ29yaXRobSkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgQ0JDRGVjcnlwdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDQkNEZWNyeXB0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ0JDRGVjcnlwdG9yKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcbiAgICAgKiBAcGFyYW0gez99IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXG4gICAgICogQHBhcmFtIHs/fSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDQkNEZWNyeXB0b3IucHJvdG90eXBlLnByb2Nlc3NCbG9jayA9IC8qKlxuICAgICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcbiAgICAgKiBAcGFyYW0gez99IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXG4gICAgICogQHBhcmFtIHs/fSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGEgYmxvY2tTaXplXG4gICAgICAgIGlmICh0aGlzLl9jaXBoZXIuY2ZnLmJsb2NrU2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgYmxvY2tTaXplIGluIGNpcGhlciBjb25maWcnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGhpc0Jsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0aGlzLl9jaXBoZXIuY2ZnLmJsb2NrU2l6ZSk7XG4gICAgICAgIC8vIERlY3J5cHQgYW5kIFhPUlxuICAgICAgICB0aGlzLl9jaXBoZXIuZGVjcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLnhvckJsb2NrKHdvcmRzLCBvZmZzZXQsIHRoaXMuX2NpcGhlci5jZmcuYmxvY2tTaXplKTtcbiAgICAgICAgLy8gVGhpcyBibG9jayBiZWNvbWVzIHRoZSBwcmV2aW91cyBibG9ja1xuICAgICAgICB0aGlzLl9wcmV2QmxvY2sgPSB0aGlzQmxvY2s7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHdvcmRzXG4gICAgICogQHBhcmFtIHs/fSBvZmZzZXRcbiAgICAgKiBAcGFyYW0gez99IGJsb2NrU2l6ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ0JDRGVjcnlwdG9yLnByb3RvdHlwZS54b3JCbG9jayA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gd29yZHNcbiAgICAgKiBAcGFyYW0gez99IG9mZnNldFxuICAgICAqIEBwYXJhbSB7P30gYmxvY2tTaXplXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAod29yZHMsIG9mZnNldCwgYmxvY2tTaXplKSB7XG4gICAgICAgIC8vIENob29zZSBtaXhpbmcgYmxvY2tcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmxvY2s7XG4gICAgICAgIGlmICh0aGlzLl9pdikge1xuICAgICAgICAgICAgYmxvY2sgPSB0aGlzLl9pdjtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBJViBmb3Igc3Vic2VxdWVudCBibG9ja3NcbiAgICAgICAgICAgIHRoaXMuX2l2ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmxvY2sgPSB0aGlzLl9wcmV2QmxvY2s7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYmxvY2sgc2hvdWxkIG5ldmVyIGJlIHVuZGVmaW5lZCBidXQgd2Ugd2FudCB0byBtYWtlIHR5cGVzY3JpcHQgaGFwcHlcbiAgICAgICAgaWYgKGJsb2NrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFhPUiBibG9ja3NcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBibG9ja1NpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHdvcmRzW29mZnNldCArIGldIF49IGJsb2NrW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ0JDRGVjcnlwdG9yO1xufShCbG9ja0NpcGhlck1vZGVBbGdvcml0aG0pKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLyoqXG4gKiBDaXBoZXIgQmxvY2sgQ2hhaW5pbmcgbW9kZS5cbiAqIEBhYnN0cmFjdFxuICovXG52YXIgQ0JDID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDQkMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ0JDKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENCQy5FbmNyeXB0b3IgPSBDQkNFbmNyeXB0b3I7XG4gICAgQ0JDLkRlY3J5cHRvciA9IENCQ0RlY3J5cHRvcjtcbiAgICByZXR1cm4gQ0JDO1xufShCbG9ja0NpcGhlck1vZGUpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIFBLQ1M3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBLQ1M3KCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYWRzIGRhdGEgdXNpbmcgdGhlIGFsZ29yaXRobSBkZWZpbmVkIGluIFBLQ1MgIzUvNy5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBQS0NTNy5wYWQod29yZEFycmF5LCA0KTtcbiAgICAgKiBAcGFyYW0gez99IGRhdGEgVGhlIGRhdGEgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7P30gYmxvY2tTaXplIFRoZSBtdWx0aXBsZSB0aGF0IHRoZSBkYXRhIHNob3VsZCBiZSBwYWRkZWQgdG8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBLQ1M3LnBhZCA9IC8qKlxuICAgICAqIFBhZHMgZGF0YSB1c2luZyB0aGUgYWxnb3JpdGhtIGRlZmluZWQgaW4gUEtDUyAjNS83LlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIFBLQ1M3LnBhZCh3b3JkQXJyYXksIDQpO1xuICAgICAqIEBwYXJhbSB7P30gZGF0YSBUaGUgZGF0YSB0byBwYWQuXG4gICAgICogQHBhcmFtIHs/fSBibG9ja1NpemUgVGhlIG11bHRpcGxlIHRoYXQgdGhlIGRhdGEgc2hvdWxkIGJlIHBhZGRlZCB0by5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKGRhdGEsIGJsb2NrU2l6ZSkge1xuICAgICAgICAvLyBTaG9ydGN1dFxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG4gICAgICAgIC8vIENvdW50IHBhZGRpbmcgYnl0ZXNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gblBhZGRpbmdCeXRlcyA9IGJsb2NrU2l6ZUJ5dGVzIC0gZGF0YS5zaWdCeXRlcyAlIGJsb2NrU2l6ZUJ5dGVzO1xuICAgICAgICAvLyBDcmVhdGUgcGFkZGluZyB3b3JkXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhZGRpbmdXb3JkID0gKG5QYWRkaW5nQnl0ZXMgPDwgMjQpIHwgKG5QYWRkaW5nQnl0ZXMgPDwgMTYpIHwgKG5QYWRkaW5nQnl0ZXMgPDwgOCkgfCBuUGFkZGluZ0J5dGVzO1xuICAgICAgICAvLyBDcmVhdGUgcGFkZGluZ1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYWRkaW5nV29yZHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IG5QYWRkaW5nQnl0ZXM7IGkgKz0gNCkge1xuICAgICAgICAgICAgcGFkZGluZ1dvcmRzLnB1c2gocGFkZGluZ1dvcmQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhZGRpbmcgPSBuZXcgV29yZEFycmF5KHBhZGRpbmdXb3JkcywgblBhZGRpbmdCeXRlcyk7XG4gICAgICAgIC8vIEFkZCBwYWRkaW5nXG4gICAgICAgIGRhdGEuY29uY2F0KHBhZGRpbmcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVW5wYWRzIGRhdGEgdGhhdCBoYWQgYmVlbiBwYWRkZWQgdXNpbmcgdGhlIGFsZ29yaXRobSBkZWZpbmVkIGluIFBLQ1MgIzUvNy5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBQS0NTNy51bnBhZCh3b3JkQXJyYXkpO1xuICAgICAqIEBwYXJhbSB7P30gZGF0YSBUaGUgZGF0YSB0byB1bnBhZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUEtDUzcudW5wYWQgPSAvKipcbiAgICAgKiBVbnBhZHMgZGF0YSB0aGF0IGhhZCBiZWVuIHBhZGRlZCB1c2luZyB0aGUgYWxnb3JpdGhtIGRlZmluZWQgaW4gUEtDUyAjNS83LlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIFBLQ1M3LnVucGFkKHdvcmRBcnJheSk7XG4gICAgICogQHBhcmFtIHs/fSBkYXRhIFRoZSBkYXRhIHRvIHVucGFkLlxuICAgICAqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAvLyBHZXQgbnVtYmVyIG9mIHBhZGRpbmcgYnl0ZXMgZnJvbSBsYXN0IGJ5dGVcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gblBhZGRpbmdCeXRlcyA9IGRhdGEud29yZHNbKGRhdGEuc2lnQnl0ZXMgLSAxKSA+Pj4gMl0gJiAweGZmO1xuICAgICAgICAvLyBSZW1vdmUgcGFkZGluZ1xuICAgICAgICBkYXRhLnNpZ0J5dGVzIC09IG5QYWRkaW5nQnl0ZXM7XG4gICAgfTtcbiAgICByZXR1cm4gUEtDUzc7XG59KCkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgIC8qKlxuICogQGFic3RyYWN0XG4gKi9cbkJsb2NrQ2lwaGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCbG9ja0NpcGhlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCbG9ja0NpcGhlcih4Zm9ybU1vZGUsIGtleSwgY2ZnKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB4Zm9ybU1vZGUsIGtleSwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAvLyBkZWZhdWx0OiAxMjggLyAzMlxuICAgICAgICAgICAgYmxvY2tTaXplOiA0LFxuICAgICAgICAgICAgbW9kZTogQ0JDLFxuICAgICAgICAgICAgcGFkZGluZzogUEtDUzdcbiAgICAgICAgfSwgY2ZnKSkgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCbG9ja0NpcGhlci5wcm90b3R5cGUucmVzZXQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUmVzZXQgY2lwaGVyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVzZXQuY2FsbCh0aGlzKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhIGJsb2NrU2l6ZVxuICAgICAgICBpZiAodGhpcy5jZmcubW9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgbW9kZSBpbiBjb25maWcnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNldCBibG9jayBtb2RlXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZGVDcmVhdG9yO1xuICAgICAgICBpZiAodGhpcy5feGZvcm1Nb2RlID09PSAoLyoqIEB0eXBlIHs/fSAqLyAodGhpcy5jb25zdHJ1Y3RvcikpLl9FTkNfWEZPUk1fTU9ERSkge1xuICAgICAgICAgICAgbW9kZUNyZWF0b3IgPSB0aGlzLmNmZy5tb2RlLmNyZWF0ZUVuY3J5cHRvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIC8qIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fREVDX1hGT1JNX01PREUpICovIHtcbiAgICAgICAgICAgIG1vZGVDcmVhdG9yID0gdGhpcy5jZmcubW9kZS5jcmVhdGVEZWNyeXB0b3I7XG4gICAgICAgICAgICAvLyBLZWVwIGF0IGxlYXN0IG9uZSBibG9jayBpbiB0aGUgYnVmZmVyIGZvciB1bnBhZGRpbmdcbiAgICAgICAgICAgIHRoaXMuX21pbkJ1ZmZlclNpemUgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9tb2RlICYmIHRoaXMuX21vZGUuX19jcmVhdG9yID09PSBtb2RlQ3JlYXRvcikge1xuICAgICAgICAgICAgdGhpcy5fbW9kZS5pbml0KHRoaXMsIHRoaXMuY2ZnLml2ICYmIHRoaXMuY2ZnLml2LndvcmRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX21vZGUgPSBtb2RlQ3JlYXRvci5jYWxsKHRoaXMuY2ZnLm1vZGUsIHRoaXMsIHRoaXMuY2ZnLml2ICYmIHRoaXMuY2ZnLml2LndvcmRzKTtcbiAgICAgICAgICAgIHRoaXMuX21vZGUuX19jcmVhdG9yID0gbW9kZUNyZWF0b3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gd29yZHNcbiAgICAgKiBAcGFyYW0gez99IG9mZnNldFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmxvY2tDaXBoZXIucHJvdG90eXBlLl9kb1Byb2Nlc3NCbG9jayA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gd29yZHNcbiAgICAgKiBAcGFyYW0gez99IG9mZnNldFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5fbW9kZS5wcm9jZXNzQmxvY2sod29yZHMsIG9mZnNldCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJsb2NrQ2lwaGVyLnByb3RvdHlwZS5fZG9GaW5hbGl6ZSA9IC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGEgcGFkZGluZyBzdHJhdGVneVxuICAgICAgICBpZiAodGhpcy5jZmcucGFkZGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcGFkZGluZyBpbiBjb25maWcnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5hbGl6ZVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaW5hbFByb2Nlc3NlZEJsb2NrcztcbiAgICAgICAgaWYgKHRoaXMuX3hmb3JtTW9kZSA9PT0gKC8qKiBAdHlwZSB7P30gKi8gKHRoaXMuY29uc3RydWN0b3IpKS5fRU5DX1hGT1JNX01PREUpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgYSBibG9ja1NpemVcbiAgICAgICAgICAgIGlmICh0aGlzLmNmZy5ibG9ja1NpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBibG9ja1NpemUgaW4gY29uZmlnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYWQgZGF0YVxuICAgICAgICAgICAgdGhpcy5jZmcucGFkZGluZy5wYWQodGhpcy5fZGF0YSwgdGhpcy5jZmcuYmxvY2tTaXplKTtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgZmluYWwgYmxvY2tzXG4gICAgICAgICAgICBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIC8qIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fREVDX1hGT1JNX01PREUpICovIHtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgZmluYWwgYmxvY2tzXG4gICAgICAgICAgICBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcbiAgICAgICAgICAgIC8vIFVucGFkIGRhdGFcbiAgICAgICAgICAgIHRoaXMuY2ZnLnBhZGRpbmcudW5wYWQoZmluYWxQcm9jZXNzZWRCbG9ja3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZEJsb2NrcztcbiAgICB9O1xuICAgIHJldHVybiBCbG9ja0NpcGhlcjtcbn0oQ2lwaGVyKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8vIERlZmluZSBsb29rdXAgdGFibGVzXG52YXIgLyoqIEB0eXBlIHs/fSAqLyBTQk9YID0gW107XG52YXIgLyoqIEB0eXBlIHs/fSAqLyBJTlZfU0JPWCA9IFtdO1xudmFyIC8qKiBAdHlwZSB7P30gKi8gU1VCX01JWF8wID0gW107XG52YXIgLyoqIEB0eXBlIHs/fSAqLyBTVUJfTUlYXzEgPSBbXTtcbnZhciAvKiogQHR5cGUgez99ICovIFNVQl9NSVhfMiA9IFtdO1xudmFyIC8qKiBAdHlwZSB7P30gKi8gU1VCX01JWF8zID0gW107XG52YXIgLyoqIEB0eXBlIHs/fSAqLyBJTlZfU1VCX01JWF8wID0gW107XG52YXIgLyoqIEB0eXBlIHs/fSAqLyBJTlZfU1VCX01JWF8xID0gW107XG52YXIgLyoqIEB0eXBlIHs/fSAqLyBJTlZfU1VCX01JWF8yID0gW107XG52YXIgLyoqIEB0eXBlIHs/fSAqLyBJTlZfU1VCX01JWF8zID0gW107XG4vLyBDb21wdXRlIGxvb2t1cCB0YWJsZXNcbihmdW5jdGlvbiAoKSB7XG4gICAgLy8gQ29tcHV0ZSBkb3VibGUgdGFibGVcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkID0gW107XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIGlmIChpIDwgMTI4KSB7XG4gICAgICAgICAgICBkW2ldID0gaSA8PCAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZFtpXSA9IChpIDw8IDEpIF4gMHgxMWI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gV2FsayBHRigyXjgpXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8geCA9IDA7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8geGkgPSAwO1xuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICAvLyBDb21wdXRlIHNib3hcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ggPSB4aSBeICh4aSA8PCAxKSBeICh4aSA8PCAyKSBeICh4aSA8PCAzKSBeICh4aSA8PCA0KTtcbiAgICAgICAgc3ggPSAoc3ggPj4+IDgpIF4gKHN4ICYgMHhmZikgXiAweDYzO1xuICAgICAgICBTQk9YW3hdID0gc3g7XG4gICAgICAgIElOVl9TQk9YW3N4XSA9IHg7XG4gICAgICAgIC8vIENvbXB1dGUgbXVsdGlwbGljYXRpb25cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8geDIgPSBkW3hdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB4NCA9IGRbeDJdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB4OCA9IGRbeDRdO1xuICAgICAgICAvLyBDb21wdXRlIHN1YiBieXRlcywgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHQgPSAoZFtzeF0gKiAweDEwMSkgXiAoc3ggKiAweDEwMTAxMDApO1xuICAgICAgICBTVUJfTUlYXzBbeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XG4gICAgICAgIFNVQl9NSVhfMVt4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG4gICAgICAgIFNVQl9NSVhfMlt4XSA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcbiAgICAgICAgU1VCX01JWF8zW3hdID0gdDtcbiAgICAgICAgLy8gQ29tcHV0ZSBpbnYgc3ViIGJ5dGVzLCBpbnYgbWl4IGNvbHVtbnMgdGFibGVzXG4gICAgICAgIHQgPSAoeDggKiAweDEwMTAxMDEpIF4gKHg0ICogMHgxMDAwMSkgXiAoeDIgKiAweDEwMSkgXiAoeCAqIDB4MTAxMDEwMCk7XG4gICAgICAgIElOVl9TVUJfTUlYXzBbc3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuICAgICAgICBJTlZfU1VCX01JWF8xW3N4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG4gICAgICAgIElOVl9TVUJfTUlYXzJbc3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuICAgICAgICBJTlZfU1VCX01JWF8zW3N4XSA9IHQ7XG4gICAgICAgIC8vIENvbXB1dGUgbmV4dCBjb3VudGVyXG4gICAgICAgIGlmICgheCkge1xuICAgICAgICAgICAgeCA9IHhpID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV07XG4gICAgICAgICAgICB4aSBePSBkW2RbeGldXTtcbiAgICAgICAgfVxuICAgIH1cbn0oKSk7XG4vLyBQcmVjb21wdXRlZCBSY29uIGxvb2t1cFxudmFyIC8qKiBAdHlwZSB7P30gKi8gUkNPTiA9IFsweDAwLCAweDAxLCAweDAyLCAweDA0LCAweDA4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XTtcbnZhciBBRVMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFFUywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBRVMoeGZvcm1Nb2RlLCBrZXksIGNmZykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgeGZvcm1Nb2RlLCBrZXksIGNmZykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBRVMucHJvdG90eXBlLnJlc2V0ID0gLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHJlc2V0IGNvcmUgdmFsdWVzXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVzZXQuY2FsbCh0aGlzKTtcbiAgICAgICAgLy8gU2tpcCByZXNldCBvZiBuUm91bmRzIGhhcyBiZWVuIHNldCBiZWZvcmUgYW5kIGtleSBkaWQgbm90IGNoYW5nZVxuICAgICAgICBpZiAodGhpcy5fblJvdW5kcyAmJiB0aGlzLl9rZXlQcmlvclJlc2V0ID09PSB0aGlzLl9rZXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaG9ydGN1dHNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5ID0gdGhpcy5fa2V5UHJpb3JSZXNldCA9IHRoaXMuX2tleTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5V29yZHMgPSBrZXkud29yZHM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleVNpemUgPSBrZXkuc2lnQnl0ZXMgLyA0O1xuICAgICAgICAvLyBDb21wdXRlIG51bWJlciBvZiByb3VuZHNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gblJvdW5kcyA9IHRoaXMuX25Sb3VuZHMgPSBrZXlTaXplICsgNjtcbiAgICAgICAgLy8gQ29tcHV0ZSBudW1iZXIgb2Yga2V5IHNjaGVkdWxlIHJvd3NcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga3NSb3dzID0gKG5Sb3VuZHMgKyAxKSAqIDQ7XG4gICAgICAgIC8vIENvbXB1dGUga2V5IHNjaGVkdWxlXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleVNjaGVkdWxlID0gdGhpcy5fa2V5U2NoZWR1bGUgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBrc1JvdyA9IDA7IGtzUm93IDwga3NSb3dzOyBrc1JvdysrKSB7XG4gICAgICAgICAgICBpZiAoa3NSb3cgPCBrZXlTaXplKSB7XG4gICAgICAgICAgICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5V29yZHNba3NSb3ddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKCEoa3NSb3cgJSBrZXlTaXplKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSb3Qgd29yZFxuICAgICAgICAgICAgICAgICAgICB0ID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTdWIgd29yZFxuICAgICAgICAgICAgICAgICAgICB0ID0gKFNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbdCAmIDB4ZmZdO1xuICAgICAgICAgICAgICAgICAgICAvLyBNaXggUmNvblxuICAgICAgICAgICAgICAgICAgICB0IF49IFJDT05bKGtzUm93IC8ga2V5U2l6ZSkgfCAwXSA8PCAyNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN1YiB3b3JkXG4gICAgICAgICAgICAgICAgICAgIHQgPSAoU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFt0ICYgMHhmZl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVNjaGVkdWxlW2tzUm93IC0ga2V5U2l6ZV0gXiB0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgaW52IGtleSBzY2hlZHVsZVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuX2ludktleVNjaGVkdWxlID0gW107XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHQgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoaW52S3NSb3cgJSA0KSB7XG4gICAgICAgICAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0KSB7XG4gICAgICAgICAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IElOVl9TVUJfTUlYXzBbU0JPWFt0ID4+PiAyNF1dIF4gSU5WX1NVQl9NSVhfMVtTQk9YWyh0ID4+PiAxNikgJiAweGZmXV0gXlxuICAgICAgICAgICAgICAgICAgICBJTlZfU1VCX01JWF8yW1NCT1hbKHQgPj4+IDgpICYgMHhmZl1dIF4gSU5WX1NVQl9NSVhfM1tTQk9YW3QgJiAweGZmXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gTVxuICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBRVMucHJvdG90eXBlLmVuY3J5cHRCbG9jayA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gTVxuICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX2tleVNjaGVkdWxlLCBTVUJfTUlYXzAsIFNVQl9NSVhfMSwgU1VCX01JWF8yLCBTVUJfTUlYXzMsIFNCT1gpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBNXG4gICAgICogQHBhcmFtIHs/fSBvZmZzZXRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFFUy5wcm90b3R5cGUuZGVjcnlwdEJsb2NrID0gLyoqXG4gICAgICogQHBhcmFtIHs/fSBNXG4gICAgICogQHBhcmFtIHs/fSBvZmZzZXRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcbiAgICAgICAgLy8gU3dhcCAybmQgYW5kIDR0aCByb3dzXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHQgPSBNW29mZnNldCArIDFdO1xuICAgICAgICBNW29mZnNldCArIDFdID0gTVtvZmZzZXQgKyAzXTtcbiAgICAgICAgTVtvZmZzZXQgKyAzXSA9IHQ7XG4gICAgICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX2ludktleVNjaGVkdWxlLCBJTlZfU1VCX01JWF8wLCBJTlZfU1VCX01JWF8xLCBJTlZfU1VCX01JWF8yLCBJTlZfU1VCX01JWF8zLCBJTlZfU0JPWCk7XG4gICAgICAgIC8vIEludiBzd2FwIDJuZCBhbmQgNHRoIHJvd3NcbiAgICAgICAgdCA9IE1bb2Zmc2V0ICsgMV07XG4gICAgICAgIE1bb2Zmc2V0ICsgMV0gPSBNW29mZnNldCArIDNdO1xuICAgICAgICBNW29mZnNldCArIDNdID0gdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gTVxuICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0XG4gICAgICogQHBhcmFtIHs/fSBrZXlTY2hlZHVsZVxuICAgICAqIEBwYXJhbSB7P30gc3ViX21peF8wXG4gICAgICogQHBhcmFtIHs/fSBzdWJfbWl4XzFcbiAgICAgKiBAcGFyYW0gez99IHN1Yl9taXhfMlxuICAgICAqIEBwYXJhbSB7P30gc3ViX21peF8zXG4gICAgICogQHBhcmFtIHs/fSBzYm94XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBRVMucHJvdG90eXBlLl9kb0NyeXB0QmxvY2sgPSAvKipcbiAgICAgKiBAcGFyYW0gez99IE1cbiAgICAgKiBAcGFyYW0gez99IG9mZnNldFxuICAgICAqIEBwYXJhbSB7P30ga2V5U2NoZWR1bGVcbiAgICAgKiBAcGFyYW0gez99IHN1Yl9taXhfMFxuICAgICAqIEBwYXJhbSB7P30gc3ViX21peF8xXG4gICAgICogQHBhcmFtIHs/fSBzdWJfbWl4XzJcbiAgICAgKiBAcGFyYW0gez99IHN1Yl9taXhfM1xuICAgICAqIEBwYXJhbSB7P30gc2JveFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKE0sIG9mZnNldCwga2V5U2NoZWR1bGUsIHN1Yl9taXhfMCwgc3ViX21peF8xLCBzdWJfbWl4XzIsIHN1Yl9taXhfMywgc2JveCkge1xuICAgICAgICAvLyBHZXQgaW5wdXQsIGFkZCByb3VuZCBrZXlcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gczAgPSBNW29mZnNldF0gXiBrZXlTY2hlZHVsZVswXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gczEgPSBNW29mZnNldCArIDFdIF4ga2V5U2NoZWR1bGVbMV07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHMyID0gTVtvZmZzZXQgKyAyXSBeIGtleVNjaGVkdWxlWzJdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzMyA9IE1bb2Zmc2V0ICsgM10gXiBrZXlTY2hlZHVsZVszXTtcbiAgICAgICAgLy8gS2V5IHNjaGVkdWxlIHJvdyBjb3VudGVyXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtzUm93ID0gNDtcbiAgICAgICAgLy8gUm91bmRzXG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gcm91bmQgPSAxOyByb3VuZCA8IHRoaXMuX25Sb3VuZHM7IHJvdW5kKyspIHtcbiAgICAgICAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgbWl4IGNvbHVtbnMsIGFkZCByb3VuZCBrZXlcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHQwID0gc3ViX21peF8wW3MwID4+PiAyNF0gXiBzdWJfbWl4XzFbKHMxID4+PiAxNikgJiAweGZmXSBeIHN1Yl9taXhfMlsoczIgPj4+IDgpICYgMHhmZl0gXiBzdWJfbWl4XzNbczMgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAga2V5U2NoZWR1bGVba3NSb3crK107XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0MSA9IHN1Yl9taXhfMFtzMSA+Pj4gMjRdIF4gc3ViX21peF8xWyhzMiA+Pj4gMTYpICYgMHhmZl0gXiBzdWJfbWl4XzJbKHMzID4+PiA4KSAmIDB4ZmZdIF4gc3ViX21peF8zW3MwICYgMHhmZl0gXlxuICAgICAgICAgICAgICAgIGtleVNjaGVkdWxlW2tzUm93KytdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdDIgPSBzdWJfbWl4XzBbczIgPj4+IDI0XSBeIHN1Yl9taXhfMVsoczMgPj4+IDE2KSAmIDB4ZmZdIF4gc3ViX21peF8yWyhzMCA+Pj4gOCkgJiAweGZmXSBeIHN1Yl9taXhfM1tzMSAmIDB4ZmZdIF5cbiAgICAgICAgICAgICAgICBrZXlTY2hlZHVsZVtrc1JvdysrXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHQzID0gc3ViX21peF8wW3MzID4+PiAyNF0gXiBzdWJfbWl4XzFbKHMwID4+PiAxNikgJiAweGZmXSBeIHN1Yl9taXhfMlsoczEgPj4+IDgpICYgMHhmZl0gXiBzdWJfbWl4XzNbczIgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAga2V5U2NoZWR1bGVba3NSb3crK107XG4gICAgICAgICAgICAvLyBVcGRhdGUgc3RhdGVcbiAgICAgICAgICAgIHMwID0gdDA7XG4gICAgICAgICAgICBzMSA9IHQxO1xuICAgICAgICAgICAgczIgPSB0MjtcbiAgICAgICAgICAgIHMzID0gdDM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBhZGQgcm91bmQga2V5XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHQwZyA9ICgoc2JveFtzMCA+Pj4gMjRdIDw8IDI0KSB8IChzYm94WyhzMSA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKHNib3hbKHMyID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgc2JveFtzMyAmIDB4ZmZdKSBeXG4gICAgICAgICAgICBrZXlTY2hlZHVsZVtrc1JvdysrXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdDFnID0gKChzYm94W3MxID4+PiAyNF0gPDwgMjQpIHwgKHNib3hbKHMyID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoc2JveFsoczMgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBzYm94W3MwICYgMHhmZl0pIF5cbiAgICAgICAgICAgIGtleVNjaGVkdWxlW2tzUm93KytdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0MmcgPSAoKHNib3hbczIgPj4+IDI0XSA8PCAyNCkgfCAoc2JveFsoczMgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChzYm94WyhzMCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IHNib3hbczEgJiAweGZmXSkgXlxuICAgICAgICAgICAga2V5U2NoZWR1bGVba3NSb3crK107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHQzZyA9ICgoc2JveFtzMyA+Pj4gMjRdIDw8IDI0KSB8IChzYm94WyhzMCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKHNib3hbKHMxID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgc2JveFtzMiAmIDB4ZmZdKSBeXG4gICAgICAgICAgICBrZXlTY2hlZHVsZVtrc1JvdysrXTtcbiAgICAgICAgLy8gU2V0IG91dHB1dFxuICAgICAgICBNW29mZnNldF0gPSB0MGc7XG4gICAgICAgIE1bb2Zmc2V0ICsgMV0gPSB0MWc7XG4gICAgICAgIE1bb2Zmc2V0ICsgMl0gPSB0Mmc7XG4gICAgICAgIE1bb2Zmc2V0ICsgM10gPSB0M2c7XG4gICAgfTtcbiAgICBBRVMua2V5U2l6ZSA9IDg7XG4gICAgcmV0dXJuIEFFUztcbn0oQmxvY2tDaXBoZXIpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuLy8gSW5pdGlhbGl6YXRpb24gYW5kIHJvdW5kIGNvbnN0YW50cyB0YWJsZXNcbnZhciAvKiogQHR5cGUgez99ICovIEggPSBbXTtcbnZhciAvKiogQHR5cGUgez99ICovIEsgPSBbXTtcbi8vIFJldXNhYmxlIG9iamVjdFxudmFyIC8qKiBAdHlwZSB7P30gKi8gVyA9IFtdO1xudmFyIFNIQTI1NiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU0hBMjU2LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNIQTI1NigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNIQTI1Ni5wcm90b3R5cGUucmVzZXQgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gcmVzZXQgY29yZSB2YWx1ZXNcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5yZXNldC5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheShILnNsaWNlKDApKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gTVxuICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTSEEyNTYucHJvdG90eXBlLl9kb1Byb2Nlc3NCbG9jayA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gTVxuICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG4gICAgICAgIC8vIFNob3J0Y3V0XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIEhsID0gdGhpcy5faGFzaC53b3JkcztcbiAgICAgICAgLy8gV29ya2luZyB2YXJpYWJsZXNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYSA9IEhsWzBdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiID0gSGxbMV07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGMgPSBIbFsyXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZCA9IEhsWzNdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlID0gSGxbNF07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGYgPSBIbFs1XTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZyA9IEhsWzZdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoID0gSGxbN107XG4gICAgICAgIC8vIENvbXB1dGF0aW9uXG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA8IDE2KSB7XG4gICAgICAgICAgICAgICAgV1tpXSA9IE1bb2Zmc2V0ICsgaV0gfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZ2FtbWEweCA9IFdbaSAtIDE1XTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBnYW1tYTAgPSAoKGdhbW1hMHggPDwgMjUpIHwgKGdhbW1hMHggPj4+IDcpKSBeXG4gICAgICAgICAgICAgICAgICAgICgoZ2FtbWEweCA8PCAxNCkgfCAoZ2FtbWEweCA+Pj4gMTgpKSBeXG4gICAgICAgICAgICAgICAgICAgIChnYW1tYTB4ID4+PiAzKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBnYW1tYTF4ID0gV1tpIC0gMl07XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZ2FtbWExID0gKChnYW1tYTF4IDw8IDE1KSB8IChnYW1tYTF4ID4+PiAxNykpIF5cbiAgICAgICAgICAgICAgICAgICAgKChnYW1tYTF4IDw8IDEzKSB8IChnYW1tYTF4ID4+PiAxOSkpIF5cbiAgICAgICAgICAgICAgICAgICAgKGdhbW1hMXggPj4+IDEwKTtcbiAgICAgICAgICAgICAgICBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaCA9IChlICYgZikgXiAofmUgJiBnKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1haiA9IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNpZ21hMCA9ICgoYSA8PCAzMCkgfCAoYSA+Pj4gMikpIF4gKChhIDw8IDE5KSB8IChhID4+PiAxMykpIF4gKChhIDw8IDEwKSB8IChhID4+PiAyMikpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2lnbWExID0gKChlIDw8IDI2KSB8IChlID4+PiA2KSkgXiAoKGUgPDwgMjEpIHwgKGUgPj4+IDExKSkgXiAoKGUgPDwgNykgfCAoZSA+Pj4gMjUpKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHQxID0gaCArIHNpZ21hMSArIGNoICsgS1tpXSArIFdbaV07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0MiA9IHNpZ21hMCArIG1hajtcbiAgICAgICAgICAgIGggPSBnO1xuICAgICAgICAgICAgZyA9IGY7XG4gICAgICAgICAgICBmID0gZTtcbiAgICAgICAgICAgIGUgPSAoZCArIHQxKSB8IDA7XG4gICAgICAgICAgICBkID0gYztcbiAgICAgICAgICAgIGMgPSBiO1xuICAgICAgICAgICAgYiA9IGE7XG4gICAgICAgICAgICBhID0gKHQxICsgdDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuICAgICAgICBIbFswXSA9IChIbFswXSArIGEpIHwgMDtcbiAgICAgICAgSGxbMV0gPSAoSGxbMV0gKyBiKSB8IDA7XG4gICAgICAgIEhsWzJdID0gKEhsWzJdICsgYykgfCAwO1xuICAgICAgICBIbFszXSA9IChIbFszXSArIGQpIHwgMDtcbiAgICAgICAgSGxbNF0gPSAoSGxbNF0gKyBlKSB8IDA7XG4gICAgICAgIEhsWzVdID0gKEhsWzVdICsgZikgfCAwO1xuICAgICAgICBIbFs2XSA9IChIbFs2XSArIGcpIHwgMDtcbiAgICAgICAgSGxbN10gPSAoSGxbN10gKyBoKSB8IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNIQTI1Ni5wcm90b3R5cGUuX2RvRmluYWxpemUgPSAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuQml0c0xlZnQgPSB0aGlzLl9kYXRhLnNpZ0J5dGVzICogODtcbiAgICAgICAgLy8gQWRkIHBhZGRpbmdcbiAgICAgICAgdGhpcy5fZGF0YS53b3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuICAgICAgICB0aGlzLl9kYXRhLndvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG4gICAgICAgIHRoaXMuX2RhdGEud29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IG5CaXRzVG90YWw7XG4gICAgICAgIHRoaXMuX2RhdGEuc2lnQnl0ZXMgPSB0aGlzLl9kYXRhLndvcmRzLmxlbmd0aCAqIDQ7XG4gICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG4gICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcbiAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc2g7XG4gICAgfTtcbiAgICByZXR1cm4gU0hBMjU2O1xufShIYXNoZXIpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIE5vUGFkZGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb1BhZGRpbmcoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvZXNuJ3QgcGFkIHRoZSBkYXRhIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIE5vUGFkZGluZy5wYWQod29yZEFycmF5LCA0KTtcbiAgICAgKiBAcGFyYW0gez99IGRhdGEgVGhlIGRhdGEgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7P30gYmxvY2tTaXplIFRoZSBtdWx0aXBsZSB0aGF0IHRoZSBkYXRhIHNob3VsZCBiZSBwYWRkZWQgdG8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vUGFkZGluZy5wYWQgPSAvKipcbiAgICAgKiBEb2Vzbid0IHBhZCB0aGUgZGF0YSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBOb1BhZGRpbmcucGFkKHdvcmRBcnJheSwgNCk7XG4gICAgICogQHBhcmFtIHs/fSBkYXRhIFRoZSBkYXRhIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0gez99IGJsb2NrU2l6ZSBUaGUgbXVsdGlwbGUgdGhhdCB0aGUgZGF0YSBzaG91bGQgYmUgcGFkZGVkIHRvLlxuICAgICAqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAoZGF0YSwgYmxvY2tTaXplKSB7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEb2Vzbid0IHVucGFkIHRoZSBkYXRhIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIE5vUGFkZGluZy51bnBhZCh3b3JkQXJyYXkpO1xuICAgICAqIEBwYXJhbSB7P30gZGF0YSBUaGUgZGF0YSB0byB1bnBhZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm9QYWRkaW5nLnVucGFkID0gLyoqXG4gICAgICogRG9lc24ndCB1bnBhZCB0aGUgZGF0YSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIFxcQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICBOb1BhZGRpbmcudW5wYWQod29yZEFycmF5KTtcbiAgICAgKiBAcGFyYW0gez99IGRhdGEgVGhlIGRhdGEgdG8gdW5wYWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgfTtcbiAgICByZXR1cm4gTm9QYWRkaW5nO1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xudmFyIEVDQkVuY3J5cHRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRUNCRW5jcnlwdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVDQkVuY3J5cHRvcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgdGhlIGRhdGEgYmxvY2sgYXQgb2Zmc2V0LlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIG1vZGUucHJvY2Vzc0Jsb2NrKGRhdGEud29yZHMsIG9mZnNldCk7XG4gICAgICogQHBhcmFtIHs/fSB3b3JkcyBUaGUgZGF0YSB3b3JkcyB0byBvcGVyYXRlIG9uLlxuICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0IFRoZSBvZmZzZXQgd2hlcmUgdGhlIGJsb2NrIHN0YXJ0cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRUNCRW5jcnlwdG9yLnByb3RvdHlwZS5wcm9jZXNzQmxvY2sgPSAvKipcbiAgICAgKiBQcm9jZXNzZXMgdGhlIGRhdGEgYmxvY2sgYXQgb2Zmc2V0LlxuICAgICAqXG4gICAgICogXFxAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgIG1vZGUucHJvY2Vzc0Jsb2NrKGRhdGEud29yZHMsIG9mZnNldCk7XG4gICAgICogQHBhcmFtIHs/fSB3b3JkcyBUaGUgZGF0YSB3b3JkcyB0byBvcGVyYXRlIG9uLlxuICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0IFRoZSBvZmZzZXQgd2hlcmUgdGhlIGJsb2NrIHN0YXJ0cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5fY2lwaGVyLmVuY3J5cHRCbG9jayh3b3Jkcywgb2Zmc2V0KTtcbiAgICB9O1xuICAgIHJldHVybiBFQ0JFbmNyeXB0b3I7XG59KEJsb2NrQ2lwaGVyTW9kZUFsZ29yaXRobSkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjaGVja2VkIGJ5IHRzY1xuICovXG52YXIgRUNCRGVjcnlwdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFQ0JEZWNyeXB0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRUNCRGVjcnlwdG9yKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcbiAgICAgKiBAcGFyYW0gez99IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXG4gICAgICogQHBhcmFtIHs/fSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFQ0JEZWNyeXB0b3IucHJvdG90eXBlLnByb2Nlc3NCbG9jayA9IC8qKlxuICAgICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBcXEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcbiAgICAgKiBAcGFyYW0gez99IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXG4gICAgICogQHBhcmFtIHs/fSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuICAgICAgICB0aGlzLl9jaXBoZXIuZGVjcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xuICAgIH07XG4gICAgcmV0dXJuIEVDQkRlY3J5cHRvcjtcbn0oQmxvY2tDaXBoZXJNb2RlQWxnb3JpdGhtKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogQ2lwaGVyIEJsb2NrIENoYWluaW5nIG1vZGUuXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIEVDQiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRUNCLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVDQigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBFQ0IuRW5jcnlwdG9yID0gRUNCRW5jcnlwdG9yO1xuICAgIEVDQi5EZWNyeXB0b3IgPSBFQ0JEZWNyeXB0b3I7XG4gICAgcmV0dXJuIEVDQjtcbn0oQmxvY2tDaXBoZXJNb2RlKSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbnZhciAvKiogQHR5cGUgez99ICovIGxpYiA9IHtcbiAgICBCbG9ja0NpcGhlcjogQmxvY2tDaXBoZXIsXG4gICAgV29yZEFycmF5OiBXb3JkQXJyYXksXG4gICAgQ2lwaGVyUGFyYW1zOiBDaXBoZXJQYXJhbXMsXG4gICAgSGFzaGVyOiBIYXNoZXIsXG4gICAgU2VyaWFsaXphYmxlQ2lwaGVyOiBTZXJpYWxpemFibGVDaXBoZXIsXG4gICAgUGFzc3dvcmRCYXNlZENpcGhlcjogUGFzc3dvcmRCYXNlZENpcGhlclxufTtcbnZhciAvKiogQHR5cGUgez99ICovIGFsZ28gPSB7XG4gICAgQUVTOiBBRVMsXG4gICAgU0hBMjU2OiBTSEEyNTZcbn07XG52YXIgLyoqIEB0eXBlIHs/fSAqLyBlbmMgPSB7XG4gICAgVXRmODogVXRmOCxcbiAgICBIZXg6IEhleFxufTtcbnZhciAvKiogQHR5cGUgez99ICovIHBhZCA9IHtcbiAgICBOb1BhZGRpbmc6IE5vUGFkZGluZyxcbiAgICBQS0NTNzogUEtDUzdcbn07XG52YXIgLyoqIEB0eXBlIHs/fSAqLyBtb2RlID0ge1xuICAgIENCQzogQ0JDLFxuICAgIEVDQjogRUNCXG59O1xuLy8gSEVMUEVSUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xudmFyIC8qKiBAdHlwZSB7P30gKi8gQUVTJDEgPSBsaWIuQmxvY2tDaXBoZXIuX2NyZWF0ZUhlbHBlcihhbGdvLkFFUyk7XG52YXIgLyoqIEB0eXBlIHs/fSAqLyBTSEEyNTYkMSA9IGxpYi5IYXNoZXIuX2NyZWF0ZUhlbHBlcihhbGdvLlNIQTI1Nik7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGNoZWNrZWQgYnkgdHNjXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gY2hlY2tlZCBieSB0c2NcbiAqL1xuXG5leHBvcnQgeyBsaWIsIGFsZ28sIGVuYywgcGFkLCBtb2RlLCBBRVMkMSBhcyBBRVMsIFNIQTI1NiQxIGFzIFNIQTI1NiwgQUVTIGFzIMm1bCwgU0hBMjU2IGFzIMm1bSwgSGV4IGFzIMm1cCwgTGF0aW4xIGFzIMm1bywgVXRmOCBhcyDJtW4sIEJhc2UgYXMgybVnLCBCbG9ja0NpcGhlciBhcyDJtWEsIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gYXMgybVjLCBDaXBoZXIgYXMgybViLCBDaXBoZXJQYXJhbXMgYXMgybVmLCBIYXNoZXIgYXMgybVpLCBQYXNzd29yZEJhc2VkQ2lwaGVyIGFzIMm1aywgU2VyaWFsaXphYmxlQ2lwaGVyIGFzIMm1aiwgV29yZEFycmF5IGFzIMm1ZSwgQmxvY2tDaXBoZXJNb2RlIGFzIMm1dCwgQ0JDIGFzIMm1cywgRUNCIGFzIMm1dSwgTm9QYWRkaW5nIGFzIMm1cSwgUEtDUzcgYXMgybVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG8tdHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/crypto-ts/esm5/crypto-ts.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/crypto-ts/node_modules/tslib/tslib.es6.js":
/*!****************************************************************!*\
  !*** ./node_modules/crypto-ts/node_modules/tslib/tslib.es6.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __assign: () => (/* binding */ __assign),\n/* harmony export */   __asyncDelegator: () => (/* binding */ __asyncDelegator),\n/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),\n/* harmony export */   __asyncValues: () => (/* binding */ __asyncValues),\n/* harmony export */   __await: () => (/* binding */ __await),\n/* harmony export */   __awaiter: () => (/* binding */ __awaiter),\n/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet),\n/* harmony export */   __createBinding: () => (/* binding */ __createBinding),\n/* harmony export */   __decorate: () => (/* binding */ __decorate),\n/* harmony export */   __exportStar: () => (/* binding */ __exportStar),\n/* harmony export */   __extends: () => (/* binding */ __extends),\n/* harmony export */   __generator: () => (/* binding */ __generator),\n/* harmony export */   __importDefault: () => (/* binding */ __importDefault),\n/* harmony export */   __importStar: () => (/* binding */ __importStar),\n/* harmony export */   __makeTemplateObject: () => (/* binding */ __makeTemplateObject),\n/* harmony export */   __metadata: () => (/* binding */ __metadata),\n/* harmony export */   __param: () => (/* binding */ __param),\n/* harmony export */   __read: () => (/* binding */ __read),\n/* harmony export */   __rest: () => (/* binding */ __rest),\n/* harmony export */   __spread: () => (/* binding */ __spread),\n/* harmony export */   __spreadArrays: () => (/* binding */ __spreadArrays),\n/* harmony export */   __values: () => (/* binding */ __values)\n/* harmony export */ });\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nfunction __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY3J5cHRvLXRzL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ25GLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1AsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2QkFBNkIsc0JBQXNCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxrREFBa0QsUUFBUTtBQUMxRCx5Q0FBeUMsUUFBUTtBQUNqRCx5REFBeUQsUUFBUTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsaUJBQWlCLHVGQUF1RixjQUFjO0FBQ3RILHVCQUF1QixnQ0FBZ0MscUNBQXFDLDJDQUEyQztBQUN2SSw0QkFBNEIsTUFBTSxpQkFBaUIsWUFBWTtBQUMvRCx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpQkFBaUIsNkNBQTZDLFVBQVUsc0RBQXNELGNBQWM7QUFDNUksMEJBQTBCLDZCQUE2QixvQkFBb0IsZ0RBQWdELGtCQUFrQjtBQUM3STtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsMkdBQTJHLHVGQUF1RixjQUFjO0FBQ2hOLHVCQUF1Qiw4QkFBOEIsZ0RBQWdELHdEQUF3RDtBQUM3Siw2Q0FBNkMsc0NBQXNDLFVBQVUsbUJBQW1CLElBQUk7QUFDcEg7QUFDQTtBQUNPO0FBQ1AsaUNBQWlDLHVDQUF1QyxZQUFZLEtBQUssT0FBTztBQUNoRztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xdWl6emVycy8uL25vZGVfbW9kdWxlcy9jcnlwdG8tdHMvbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcz9hMWI3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NyZWF0ZUJpbmRpbmcobywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcclxuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgIHJldHVybiByO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0LmRlZmF1bHQgPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcclxuICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgcHJpdmF0ZU1hcCwgdmFsdWUpIHtcclxuICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XHJcbiAgICB9XHJcbiAgICBwcml2YXRlTWFwLnNldChyZWNlaXZlciwgdmFsdWUpO1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/crypto-ts/node_modules/tslib/tslib.es6.js\n");

/***/ })

};
;